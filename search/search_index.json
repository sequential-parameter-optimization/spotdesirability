{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spotpython","text":""},{"location":"#surrogate-model-based-optimization-and-hyperparameter-tuning-in-python","title":"Surrogate Model Based Optimization and Hyperparameter Tuning in Python","text":"<ul> <li>Documentation for spotpython see Hyperparameter Tuning Cookbook, a guide for scikit-learn, PyTorch, river, and spotpython.</li> <li>News and updates related to spotpython see SPOTSeven</li> </ul>"},{"location":"about/","title":"Contact/Privacy Policy","text":""},{"location":"about/#address","title":"Address","text":"<p>Your Address</p>"},{"location":"about/#privacy-policy","title":"Privacy Policy","text":"<p>We are very delighted that you have shown interest in our enterprise. Data protection is of a particularly high priority for the management of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab. The use of the Internet pages of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab is possible without any indication of personal data; however, if a data subject wants to use special enterprise services via our website, processing of personal data could become necessary. If the processing of personal data is necessary and there is no statutory basis for such processing, we generally obtain consent from the data subject.</p> <p>The processing of personal data, such as the name, address, e-mail address, or telephone number of a data subject shall always be in line with the General Data Protection Regulation (GDPR), and in accordance with the country-specific data protection regulations applicable to the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab. By means of this data protection declaration, our enterprise would like to inform the general public of the nature, scope, and purpose of the personal data we collect, use and process. Furthermore, data subjects are informed, by means of this data protection declaration, of the rights to which they are entitled.</p> <p>As the controller, the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab has implemented numerous technical and organizational measures to ensure the most complete protection of personal data processed through this website. However, Internet-based data transmissions may in principle have security gaps, so absolute protection may not be guaranteed. For this reason, every data subject is free to transfer personal data to us via alternative means, e.g. by telephone.</p> <ol> <li>Definitions</li> </ol> <p>The data protection declaration of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab is based on the terms used by the European legislator for the adoption of the General Data Protection Regulation (GDPR). Our data protection declaration should be legible and understandable for the general public, as well as our customers and business partners. To ensure this, we would like to first explain the terminology used.</p> <p>In this data protection declaration, we use, inter alia, the following terms:</p> <p>a)    Personal data</p> <p>Personal data means any information relating to an identified or identifiable natural person (\u201cdata subject\u201d). An identifiable natural person is one who can be identified, directly or indirectly, in particular by reference to an identifier such as a name, an identification number, location data, an online identifier or to one or more factors specific to the physical, physiological, genetic, mental, economic, cultural or social identity of that natural person.</p> <p>b) Data subject</p> <p>Data subject is any identified or identifiable natural person, whose personal data is processed by the controller responsible for the processing.</p> <p>c)    Processing</p> <p>Processing is any operation or set of operations which is performed on personal data or on sets of personal data, whether or not by automated means, such as collection, recording, organisation, structuring, storage, adaptation or alteration, retrieval, consultation, use, disclosure by transmission, dissemination or otherwise making available, alignment or combination, restriction, erasure or destruction.</p> <p>d)    Restriction of processing</p> <p>Restriction of processing is the marking of stored personal data with the aim of limiting their processing in the future.</p> <p>e)    Profiling</p> <p>Profiling means any form of automated processing of personal data consisting of the use of personal data to evaluate certain personal aspects relating to a natural person, in particular to analyse or predict aspects concerning that natural person\u2019s performance at work, economic situation, health, personal preferences, interests, reliability, behaviour, location or movements.</p> <p>f)     Pseudonymisation</p> <p>Pseudonymisation is the processing of personal data in such a manner that the personal data can no longer be attributed to a specific data subject without the use of additional information, provided that such additional information is kept separately and is subject to technical and organisational measures to ensure that the personal data are not attributed to an identified or identifiable natural person.</p> <p>g)    Controller or controller responsible for the processing</p> <p>Controller or controller responsible for the processing is the natural or legal person, public authority, agency or other body which, alone or jointly with others, determines the purposes and means of the processing of personal data; where the purposes and means of such processing are determined by Union or Member State law, the controller or the specific criteria for its nomination may be provided for by Union or Member State law.</p> <p>h)    Processor</p> <p>Processor is a natural or legal person, public authority, agency or other body which processes personal data on behalf of the controller.</p> <p>i)      Recipient</p> <p>Recipient is a natural or legal person, public authority, agency or another body, to which the personal data are disclosed, whether a third party or not. However, public authorities which may receive personal data in the framework of a particular inquiry in accordance with Union or Member State law shall not be regarded as recipients; the processing of those data by those public authorities shall be in compliance with the applicable data protection rules according to the purposes of the processing.</p> <p>j)      Third party</p> <p>Third party is a natural or legal person, public authority, agency or body other than the data subject, controller, processor and persons who, under the direct authority of the controller or processor, are authorised to process personal data.</p> <p>k)    Consent</p> <p>Consent of the data subject is any freely given, specific, informed and unambiguous indication of the data subject\u2019s wishes by which he or she, by a statement or by a clear affirmative action, signifies agreement to the processing of personal data relating to him or her.</p> <ol> <li>Name and Address of the controller</li> </ol> <p>Controller for the purposes of the General Data Protection Regulation (GDPR), other data protection laws applicable in Member states of the European Union and other provisions related to data protection is:</p> <ol> <li>Collection of general data and information</li> </ol> <p>The website of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab collects a series of general data and information when a data subject or automated system calls up the website. This general data and information are stored in the server log files. Collected may be (1) the browser types and versions used, (2) the operating system used by the accessing system, (3) the website from which an accessing system reaches our website (so-called referrers), (4) the sub-websites, (5) the date and time of access to the Internet site, (6) an Internet protocol address (IP address), (7) the Internet service provider of the accessing system, and (8) any other similar data and information that may be used in the event of attacks on our information technology systems.</p> <p>When using these general data and information, the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab does not draw any conclusions about the data subject. Rather, this information is needed to (1) deliver the content of our website correctly, (2) optimize the content of our website as well as its advertisement, (3) ensure the long-term viability of our information technology systems and website technology, and (4) provide law enforcement authorities with the information necessary for criminal prosecution in case of a cyber-attack. Therefore, the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab analyzes anonymously collected data and information statistically, with the aim of increasing the data protection and data security of our enterprise, and to ensure an optimal level of protection for the personal data we process. The anonymous data of the server log files are stored separately from all personal data provided by a data subject.</p> <ol> <li>Comments function in the blog on the website</li> </ol> <p>The TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab offers users the possibility to leave individual comments on individual blog contributions on a blog, which is on the website of the controller. A blog is a web-based, publicly-accessible portal, through which one or more people called bloggers or web-bloggers may post articles or write down thoughts in so-called blogposts. Blogposts may usually be commented by third parties.</p> <p>If a data subject leaves a comment on the blog published on this website, the comments made by the data subject are also stored and published, as well as information on the date of the commentary and on the user\u2019s (pseudonym) chosen by the data subject. In addition, the IP address assigned by the Internet service provider (ISP) to the data subject is also logged. This storage of the IP address takes place for security reasons, and in case the data subject violates the rights of third parties, or posts illegal content through a given comment. The storage of these personal data is, therefore, in the own interest of the data controller, so that he can exculpate in the event of an infringement. This collected personal data will not be passed to third parties, unless such a transfer is required by law or serves the aim of the defense of the data controller.</p> <ol> <li>Routine erasure and blocking of personal data</li> </ol> <p>The data controller shall process and store the personal data of the data subject only for the period necessary to achieve the purpose of storage, or as far as this is granted by the European legislator or other legislators in laws or regulations to which the controller is subject to.</p> <p>If the storage purpose is not applicable, or if a storage period prescribed by the European legislator or another competent legislator expires, the personal data are routinely blocked or erased in accordance with legal requirements.</p> <ol> <li>Rights of the data subject</li> </ol> <p>a) Right of confirmation</p> <p>Each data subject shall have the right granted by the European legislator to obtain from the controller the confirmation as to whether or not personal data concerning him or her are being processed. If a data subject wishes to avail himself of this right of confirmation, he or she may, at any time, contact our Data Protection Officer or another employee of the controller.</p> <p>b) Right of access</p> <p>Each data subject shall have the right granted by the European legislator to obtain from the controller free information about his or her personal data stored at any time and a copy of this information. Furthermore, the European directives and regulations grant the data subject access to the following information:</p> <p>the purposes of the processing; the categories of personal data concerned; the recipients or categories of recipients to whom the personal data have been or will be disclosed, in particular recipients in third countries or international organisations; where possible, the envisaged period for which the personal data will be stored, or, if not possible, the criteria used to determine that period; the existence of the right to request from the controller rectification or erasure of personal data, or restriction of processing of personal data concerning the data subject, or to object to such processing; the existence of the right to lodge a complaint with a supervisory authority; where the personal data are not collected from the data subject, any available information as to their source; the existence of automated decision-making, including profiling, referred to in Article 22(1) and (4) of the GDPR and, at least in those cases, meaningful information about the logic involved, as well as the significance and envisaged consequences of such processing for the data subject. Furthermore, the data subject shall have a right to obtain information as to whether personal data are transferred to a third country or to an international organisation. Where this is the case, the data subject shall have the right to be informed of the appropriate safeguards relating to the transfer.</p> <p>If a data subject wishes to avail himself of this right of access, he or she may at any time contact our Data Protection Officer or another employee of the controller.</p> <p>c) Right to rectification</p> <p>Each data subject shall have the right granted by the European legislator to obtain from the controller without undue delay the rectification of inaccurate personal data concerning him or her. Taking into account the purposes of the processing, the data subject shall have the right to have incomplete personal data completed, including by means of providing a supplementary statement.</p> <p>If a data subject wishes to exercise this right to rectification, he or she may, at any time, contact our Data Protection Officer or another employee of the controller.</p> <p>d) Right to erasure (Right to be forgotten)</p> <p>Each data subject shall have the right granted by the European legislator to obtain from the controller the erasure of personal data concerning him or her without undue delay, and the controller shall have the obligation to erase personal data without undue delay where one of the following grounds applies, as long as the processing is not necessary:</p> <p>The personal data are no longer necessary in relation to the purposes for which they were collected or otherwise processed. The data subject withdraws consent to which the processing is based according to point (a) of Article 6(1) of the GDPR, or point (a) of Article 9(2) of the GDPR, and where there is no other legal ground for the processing. The data subject objects to the processing pursuant to Article 21(1) of the GDPR and there are no overriding legitimate grounds for the processing, or the data subject objects to the processing pursuant to Article 21(2) of the GDPR. The personal data have been unlawfully processed. The personal data must be erased for compliance with a legal obligation in Union or Member State law to which the controller is subject. The personal data have been collected in relation to the offer of information society services referred to in Article 8(1) of the GDPR. If one of the aforementioned reasons applies, and a data subject wishes to request the erasure of personal data stored by the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab, he or she may at any time contact our Data Protection Officer or another employee of the controller. The Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee shall promptly ensure that the erasure request is complied with immediately.</p> <p>Where the controller has made personal data public and is obliged pursuant to Article 17(1) to erase the personal data, the controller, taking account of available technology and the cost of implementation, shall take reasonable steps, including technical measures, to inform other controllers processing the personal data that the data subject has requested erasure by such controllers of any links to, or copy or replication of, those personal data, as far as processing is not required. The Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee will arrange the necessary measures in individual cases.</p> <p>e) Right of restriction of processing</p> <p>Each data subject shall have the right granted by the European legislator to obtain from the controller restriction of processing where one of the following applies:</p> <p>The accuracy of the personal data is contested by the data subject, for a period enabling the controller to verify the accuracy of the personal data. The processing is unlawful and the data subject opposes the erasure of the personal data and requests instead the restriction of their use instead. The controller no longer needs the personal data for the purposes of the processing, but they are required by the data subject for the establishment, exercise or defence of legal claims. The data subject has objected to processing pursuant to Article 21(1) of the GDPR pending the verification whether the legitimate grounds of the controller override those of the data subject. If one of the aforementioned conditions is met, and a data subject wishes to request the restriction of the processing of personal data stored by the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab, he or she may at any time contact our Data Protection Officer or another employee of the controller. The Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee will arrange the restriction of the processing.</p> <p>f) Right to data portability</p> <p>Each data subject shall have the right granted by the European legislator, to receive the personal data concerning him or her, which was provided to a controller, in a structured, commonly used and machine-readable format. He or she shall have the right to transmit those data to another controller without hindrance from the controller to which the personal data have been provided, as long as the processing is based on consent pursuant to point (a) of Article 6(1) of the GDPR or point (a) of Article 9(2) of the GDPR, or on a contract pursuant to point (b) of Article 6(1) of the GDPR, and the processing is carried out by automated means, as long as the processing is not necessary for the performance of a task carried out in the public interest or in the exercise of official authority vested in the controller.</p> <p>Furthermore, in exercising his or her right to data portability pursuant to Article 20(1) of the GDPR, the data subject shall have the right to have personal data transmitted directly from one controller to another, where technically feasible and when doing so does not adversely affect the rights and freedoms of others.</p> <p>In order to assert the right to data portability, the data subject may at any time contact the Data Protection Officer designated by the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee.</p> <p>g) Right to object</p> <p>Each data subject shall have the right granted by the European legislator to object, on grounds relating to his or her particular situation, at any time, to processing of personal data concerning him or her, which is based on point (e) or (f) of Article 6(1) of the GDPR. This also applies to profiling based on these provisions.</p> <p>The TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab shall no longer process the personal data in the event of the objection, unless we can demonstrate compelling legitimate grounds for the processing which override the interests, rights and freedoms of the data subject, or for the establishment, exercise or defence of legal claims.</p> <p>If the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab processes personal data for direct marketing purposes, the data subject shall have the right to object at any time to processing of personal data concerning him or her for such marketing. This applies to profiling to the extent that it is related to such direct marketing. If the data subject objects to the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab to the processing for direct marketing purposes, the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab will no longer process the personal data for these purposes.</p> <p>In addition, the data subject has the right, on grounds relating to his or her particular situation, to object to processing of personal data concerning him or her by the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab for scientific or historical research purposes, or for statistical purposes pursuant to Article 89(1) of the GDPR, unless the processing is necessary for the performance of a task carried out for reasons of public interest.</p> <p>In order to exercise the right to object, the data subject may directly contact the Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee. In addition, the data subject is free in the context of the use of information society services, and notwithstanding Directive 2002/58/EC, to use his or her right to object by automated means using technical specifications.</p> <p>h) Automated individual decision-making, including profiling</p> <p>Each data subject shall have the right granted by the European legislator not to be subject to a decision based solely on automated processing, including profiling, which produces legal effects concerning him or her, or similarly significantly affects him or her, as long as the decision (1) is not is necessary for entering into, or the performance of, a contract between the data subject and a data controller, or (2) is not authorised by Union or Member State law to which the controller is subject and which also lays down suitable measures to safeguard the data subject\u2019s rights and freedoms and legitimate interests, or (3) is not based on the data subject\u2019s explicit consent.</p> <p>If the decision (1) is necessary for entering into, or the performance of, a contract between the data subject and a data controller, or (2) it is based on the data subject\u2019s explicit consent, the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab shall implement suitable measures to safeguard the data subject\u2019s rights and freedoms and legitimate interests, at least the right to obtain human intervention on the part of the controller, to express his or her point of view and contest the decision.</p> <p>If the data subject wishes to exercise the rights concerning automated individual decision-making, he or she may at any time directly contact our Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee of the controller.</p> <p>i) Right to withdraw data protection consent</p> <p>Each data subject shall have the right granted by the European legislator to withdraw his or her consent to processing of his or her personal data at any time.</p> <p>f the data subject wishes to exercise the right to withdraw the consent, he or she may at any time directly contact our Data Protection Officer of the TH K\u00f6ln, Fakult\u00e4t Informatik und Ingenieurwissenschaften, SPOTSeven Lab or another employee of the controller.</p> <ol> <li>Data protection provisions about the application and use of Facebook</li> </ol> <p>On this website, the controller has integrated components of the enterprise Facebook. Facebook is a social network.</p> <p>A social network is a place for social meetings on the Internet, an online community, which usually allows users to communicate with each other and interact in a virtual space. A social network may serve as a platform for the exchange of opinions and experiences, or enable the Internet community to provide personal or business-related information. Facebook allows social network users to include the creation of private profiles, upload photos, and network through friend requests.</p> <p>The operating company of Facebook is Facebook, Inc., 1 Hacker Way, Menlo Park, CA 94025, United States. If a person lives outside of the United States or Canada, the controller is the Facebook Ireland Ltd., 4 Grand Canal Square, Grand Canal Harbour, Dublin 2, Ireland.</p> <p>With each call-up to one of the individual pages of this Internet website, which is operated by the controller and into which a Facebook component (Facebook plug-ins) was integrated, the web browser on the information technology system of the data subject is automatically prompted to download display of the corresponding Facebook component from Facebook through the Facebook component. An overview of all the Facebook Plug-ins may be accessed under https://developers.facebook.com/docs/plugins/. During the course of this technical procedure, Facebook is made aware of what specific sub-site of our website was visited by the data subject.</p> <p>If the data subject is logged in at the same time on Facebook, Facebook detects with every call-up to our website by the data subject\u2014and for the entire duration of their stay on our Internet site\u2014which specific sub-site of our Internet page was visited by the data subject. This information is collected through the Facebook component and associated with the respective Facebook account of the data subject. If the data subject clicks on one of the Facebook buttons integrated into our website, e.g. the \u201cLike\u201d button, or if the data subject submits a comment, then Facebook matches this information with the personal Facebook user account of the data subject and stores the personal data.</p> <p>Facebook always receives, through the Facebook component, information about a visit to our website by the data subject, whenever the data subject is logged in at the same time on Facebook during the time of the call-up to our website. This occurs regardless of whether the data subject clicks on the Facebook component or not. If such a transmission of information to Facebook is not desirable for the data subject, then he or she may prevent this by logging off from their Facebook account before a call-up to our website is made.</p> <p>The data protection guideline published by Facebook, which is available at https://facebook.com/about/privacy/, provides information about the collection, processing and use of personal data by Facebook. In addition, it is explained there what setting options Facebook offers to protect the privacy of the data subject. In addition, different configuration options are made available to allow the elimination of data transmission to Facebook, e.g. the Facebook blocker of the provider Webgraph, which may be obtained under http://webgraph.com/resources/facebookblocker/. These applications may be used by the data subject to eliminate a data transmission to Facebook.</p> <ol> <li>Data protection provisions about the application and use of Google+</li> </ol> <p>On this website, the controller has integrated the Google+ button as a component. Google+ is a so-called social network. A social network is a social meeting place on the Internet, an online community, which usually allows users to communicate with each other and interact in a virtual space. A social network may serve as a platform for the exchange of opinions and experiences, or enable the Internet community to provide personal or business-related information. Google+ allows users of the social network to include the creation of private profiles, upload photos and network through friend requests.</p> <p>The operating company of Google+ is Google Inc., 1600 Amphitheatre Pkwy, Mountain View, CA 94043-1351, UNITED STATES.</p> <p>With each call-up to one of the individual pages of this website, which is operated by the controller and on which a Google+ button has been integrated, the Internet browser on the information technology system of the data subject automatically downloads a display of the corresponding Google+ button of Google through the respective Google+ button component. During the course of this technical procedure, Google is made aware of what specific sub-page of our website was visited by the data subject. More detailed information about Google+ is available under https://developers.google.com/+/.</p> <p>If the data subject is logged in at the same time to Google+, Google recognizes with each call-up to our website by the data subject and for the entire duration of his or her stay on our Internet site, which specific sub-pages of our Internet page were visited by the data subject. This information is collected through the Google+ button and Google matches this with the respective Google+ account associated with the data subject.</p> <p>If the data subject clicks on the Google+ button integrated on our website and thus gives a Google+ 1 recommendation, then Google assigns this information to the personal Google+ user account of the data subject and stores the personal data. Google stores the Google+ 1 recommendation of the data subject, making it publicly available in accordance with the terms and conditions accepted by the data subject in this regard. Subsequently, a Google+ 1 recommendation given by the data subject on this website together with other personal data, such as the Google+ account name used by the data subject and the stored photo, is stored and processed on other Google services, such as search-engine results of the Google search engine, the Google account of the data subject or in other places, e.g. on Internet pages, or in relation to advertisements. Google is also able to link the visit to this website with other personal data stored on Google. Google further records this personal information with the purpose of improving or optimizing the various Google services.</p> <p>Through the Google+ button, Google receives information that the data subject visited our website, if the data subject at the time of the call-up to our website is logged in to Google+. This occurs regardless of whether the data subject clicks or doesn\u2019t click on the Google+ button.</p> <p>If the data subject does not wish to transmit personal data to Google, he or she may prevent such transmission by logging out of his Google+ account before calling up our website.</p> <p>Further information and the data protection provisions of Google may be retrieved under https://www.google.com/intl/en/policies/privacy/. More references from Google about the Google+ 1 button may be obtained under https://developers.google.com/+/web/buttons-policy.</p> <ol> <li>Data protection provisions about the application and use of Jetpack for WordPress</li> </ol> <p>On this website, the controller has integrated Jetpack. Jetpack is a WordPress plug-in, which provides additional features to the operator of a website based on WordPress. Jetpack allows the Internet site operator, inter alia, an overview of the visitors of the site. By displaying related posts and publications, or the ability to share content on the page, it is also possible to increase visitor numbers. In addition, security features are integrated into Jetpack, so a Jetpack-using site is better protected against brute-force attacks. Jetpack also optimizes and accelerates the loading of images on the website.</p> <p>The operating company of Jetpack Plug-Ins for WordPress is the Automattic Inc., 132 Hawthorne Street, San Francisco, CA 94107, UNITED STATES. The operating enterprise uses the tracking technology created by Quantcast Inc., 201 Third Street, San Francisco, CA 94103, UNITED STATES.</p> <p>Jetpack sets a cookie on the information technology system used by the data subject. The definition of cookies is explained above. With each call-up to one of the individual pages of this Internet site, which is operated by the controller and on which a Jetpack component was integrated, the Internet browser on the information technology system of the data subject is automatically prompted to submit data through the Jetpack component for analysis purposes to Automattic. During the course of this technical procedure Automattic receives data that is used to create an overview of website visits. The data obtained in this way serves the analysis of the behaviour of the data subject, which has access to the Internet page of the controller and is analyzed with the aim to optimize the website. The data collected through the Jetpack component is not used to identify the data subject without a prior obtaining of a separate express consent of the data subject. The data comes also to the notice of Quantcast. Quantcast uses the data for the same purposes as Automattic.</p> <p>The data subject can, as stated above, prevent the setting of cookies through our website at any time by means of a corresponding adjustment of the web browser used and thus permanently deny the setting of cookies. Such an adjustment to the Internet browser used would also prevent Automattic/Quantcast from setting a cookie on the information technology system of the data subject. In addition, cookies already in use by Automattic/Quantcast may be deleted at any time via a web browser or other software programs.</p> <p>In addition, the data subject has the possibility of objecting to a collection of data relating to a use of this Internet site that are generated by the Jetpack cookie as well as the processing of these data by Automattic/Quantcast and the chance to preclude any such. For this purpose, the data subject must press the \u2018opt-out\u2019 button under the link https://www.quantcast.com/opt-out/ which sets an opt-out cookie. The opt-out cookie set with this purpose is placed on the information technology system used by the data subject. If the cookies are deleted on the system of the data subject, then the data subject must call up the link again and set a new opt-out cookie.</p> <p>With the setting of the opt-out cookie, however, the possibility exists that the websites of the controller are not fully usable anymore by the data subject.</p> <p>The applicable data protection provisions of Automattic may be accessed under https://automattic.com/privacy/. The applicable data protection provisions of Quantcast can be accessed under https://www.quantcast.com/privacy/.</p> <ol> <li>Data protection provisions about the application and use of LinkedIn</li> </ol> <p>The controller has integrated components of the LinkedIn Corporation on this website. LinkedIn is a web-based social network that enables users with existing business contacts to connect and to make new business contacts. Over 400 million registered people in more than 200 countries use LinkedIn. Thus, LinkedIn is currently the largest platform for business contacts and one of the most visited websites in the world.</p> <p>The operating company of LinkedIn is LinkedIn Corporation, 2029 Stierlin Court Mountain View, CA 94043, UNITED STATES. For privacy matters outside of the UNITED STATES LinkedIn Ireland, Privacy Policy Issues, Wilton Plaza, Wilton Place, Dublin 2, Ireland, is responsible.</p> <p>With each call-up to one of the individual pages of this Internet site, which is operated by the controller and on which a LinkedIn component (LinkedIn plug-in) was integrated, the Internet browser on the information technology system of the data subject is automatically prompted to the download of a display of the corresponding LinkedIn component of LinkedIn. Further information about the LinkedIn plug-in may be accessed under https://developer.linkedin.com/plugins. During the course of this technical procedure, LinkedIn gains knowledge of what specific sub-page of our website was visited by the data subject.</p> <p>If the data subject is logged in at the same time on LinkedIn, LinkedIn detects with every call-up to our website by the data subject\u2014and for the entire duration of their stay on our Internet site\u2014which specific sub-page of our Internet page was visited by the data subject. This information is collected through the LinkedIn component and associated with the respective LinkedIn account of the data subject. If the data subject clicks on one of the LinkedIn buttons integrated on our website, then LinkedIn assigns this information to the personal LinkedIn user account of the data subject and stores the personal data.</p> <p>LinkedIn receives information via the LinkedIn component that the data subject has visited our website, provided that the data subject is logged in at LinkedIn at the time of the call-up to our website. This occurs regardless of whether the person clicks on the LinkedIn button or not. If such a transmission of information to LinkedIn is not desirable for the data subject, then he or she may prevent this by logging off from their LinkedIn account before a call-up to our website is made.</p> <p>LinkedIn provides under https://www.linkedin.com/psettings/guest-controls the possibility to unsubscribe from e-mail messages, SMS messages and targeted ads, as well as the ability to manage ad settings. LinkedIn also uses affiliates such as Eire, Google Analytics, BlueKai, DoubleClick, Nielsen, Comscore, Eloqua, and Lotame. The setting of such cookies may be denied under https://www.linkedin.com/legal/cookie-policy. The applicable privacy policy for LinkedIn is available under https://www.linkedin.com/legal/privacy-policy. The LinkedIn Cookie Policy is available under https://www.linkedin.com/legal/cookie-policy.</p> <ol> <li>Data protection provisions about the application and use of Twitter</li> </ol> <p>On this website, the controller has integrated components of Twitter. Twitter is a multilingual, publicly-accessible microblogging service on which users may publish and spread so-called \u2018tweets,\u2019 e.g. short messages, which are limited to 140 characters. These short messages are available for everyone, including those who are not logged on to Twitter. The tweets are also displayed to so-called followers of the respective user. Followers are other Twitter users who follow a user\u2019s tweets. Furthermore, Twitter allows you to address a wide audience via hashtags, links or retweets.</p> <p>The operating company of Twitter is Twitter, Inc., 1355 Market Street, Suite 900, San Francisco, CA 94103, UNITED STATES.</p> <p>With each call-up to one of the individual pages of this Internet site, which is operated by the controller and on which a Twitter component (Twitter button) was integrated, the Internet browser on the information technology system of the data subject is automatically prompted to download a display of the corresponding Twitter component of Twitter. Further information about the Twitter buttons is available under https://about.twitter.com/de/resources/buttons. During the course of this technical procedure, Twitter gains knowledge of what specific sub-page of our website was visited by the data subject. The purpose of the integration of the Twitter component is a retransmission of the contents of this website to allow our users to introduce this web page to the digital world and increase our visitor numbers.</p> <p>If the data subject is logged in at the same time on Twitter, Twitter detects with every call-up to our website by the data subject and for the entire duration of their stay on our Internet site which specific sub-page of our Internet page was visited by the data subject. This information is collected through the Twitter component and associated with the respective Twitter account of the data subject. If the data subject clicks on one of the Twitter buttons integrated on our website, then Twitter assigns this information to the personal Twitter user account of the data subject and stores the personal data.</p> <p>Twitter receives information via the Twitter component that the data subject has visited our website, provided that the data subject is logged in on Twitter at the time of the call-up to our website. This occurs regardless of whether the person clicks on the Twitter component or not. If such a transmission of information to Twitter is not desirable for the data subject, then he or she may prevent this by logging off from their Twitter account before a call-up to our website is made.</p> <p>The applicable data protection provisions of Twitter may be accessed under https://twitter.com/privacy?lang=en.</p> <ol> <li>Data protection provisions about the application and use of YouTube</li> </ol> <p>On this website, the controller has integrated components of YouTube. YouTube is an Internet video portal that enables video publishers to set video clips and other users free of charge, which also provides free viewing, review and commenting on them. YouTube allows you to publish all kinds of videos, so you can access both full movies and TV broadcasts, as well as music videos, trailers, and videos made by users via the Internet portal.</p> <p>The operating company of YouTube is YouTube, LLC, 901 Cherry Ave., San Bruno, CA 94066, UNITED STATES. The YouTube, LLC is a subsidiary of Google Inc., 1600 Amphitheatre Pkwy, Mountain View, CA 94043-1351, UNITED STATES.</p> <p>With each call-up to one of the individual pages of this Internet site, which is operated by the controller and on which a YouTube component (YouTube video) was integrated, the Internet browser on the information technology system of the data subject is automatically prompted to download a display of the corresponding YouTube component. Further information about YouTube may be obtained under https://www.youtube.com/yt/about/en/. During the course of this technical procedure, YouTube and Google gain knowledge of what specific sub-page of our website was visited by the data subject.</p> <p>If the data subject is logged in on YouTube, YouTube recognizes with each call-up to a sub-page that contains a YouTube video, which specific sub-page of our Internet site was visited by the data subject. This information is collected by YouTube and Google and assigned to the respective YouTube account of the data subject.</p> <p>YouTube and Google will receive information through the YouTube component that the data subject has visited our website, if the data subject at the time of the call to our website is logged in on YouTube; this occurs regardless of whether the person clicks on a YouTube video or not. If such a transmission of this information to YouTube and Google is not desirable for the data subject, the delivery may be prevented if the data subject logs off from their own YouTube account before a call-up to our website is made.</p> <p>YouTube\u2019s data protection provisions, available at https://www.google.com/intl/en/policies/privacy/, provide information about the collection, processing and use of personal data by YouTube and Google.</p> <ol> <li>Legal basis for the processing</li> </ol> <p>Art. 6(1) lit. a GDPR serves as the legal basis for processing operations for which we obtain consent for a specific processing purpose. If the processing of personal data is necessary for the performance of a contract to which the data subject is party, as is the case, for example, when processing operations are necessary for the supply of goods or to provide any other service, the processing is based on Article 6(1) lit. b GDPR. The same applies to such processing operations which are necessary for carrying out pre-contractual measures, for example in the case of inquiries concerning our products or services. Is our company subject to a legal obligation by which processing of personal data is required, such as for the fulfillment of tax obligations, the processing is based on Art. 6(1) lit. c GDPR. In rare cases, the processing of personal data may be necessary to protect the vital interests of the data subject or of another natural person. This would be the case, for example, if a visitor were injured in our company and his name, age, health insurance data or other vital information would have to be passed on to a doctor, hospital or other third party. Then the processing would be based on Art. 6(1) lit. d GDPR. Finally, processing operations could be based on Article 6(1) lit. f GDPR. This legal basis is used for processing operations which are not covered by any of the abovementioned legal grounds, if processing is necessary for the purposes of the legitimate interests pursued by our company or by a third party, except where such interests are overridden by the interests or fundamental rights and freedoms of the data subject which require protection of personal data. Such processing operations are particularly permissible because they have been specifically mentioned by the European legislator. He considered that a legitimate interest could be assumed if the data subject is a client of the controller (Recital 47 Sentence 2 GDPR).</p> <ol> <li>The legitimate interests pursued by the controller or by a third party</li> </ol> <p>Where the processing of personal data is based on Article 6(1) lit. f GDPR our legitimate interest is to carry out our business in favor of the well-being of all our employees and the shareholders.</p> <ol> <li>Period for which the personal data will be stored</li> </ol> <p>The criteria used to determine the period of storage of personal data is the respective statutory retention period. After expiration of that period, the corresponding data is routinely deleted, as long as it is no longer necessary for the fulfillment of the contract or the initiation of a contract.</p> <ol> <li>Provision of personal data as statutory or contractual requirement; Requirement necessary to enter into a contract; Obligation of the data subject to provide the personal data; possible consequences of failure to provide such data</li> </ol> <p>We clarify that the provision of personal data is partly required by law (e.g. tax regulations) or can also result from contractual provisions (e.g. information on the contractual partner). Sometimes it may be necessary to conclude a contract that the data subject provides us with personal data, which must subsequently be processed by us. The data subject is, for example, obliged to provide us with personal data when our company signs a contract with him or her. The non-provision of the personal data would have the consequence that the contract with the data subject could not be concluded. Before personal data is provided by the data subject, the data subject must contact our Data Protection Officer. Our Data Protection Officer clarifies to the data subject whether the provision of the personal data is required by law or contract or is necessary for the conclusion of the contract, whether there is an obligation to provide the personal data and the consequences of non-provision of the personal data.</p> <ol> <li>Existence of automated decision-making</li> </ol> <p>As a responsible company, we do not use automatic decision-making or profiling.</p> <p>This Privacy Policy has been generated by the Privacy Policy Generator of the External Data Protection Officers that was developed in cooperation with RC GmbH, which sells used notebooks and the Media Law Lawyers from WBS-LAW.</p>"},{"location":"download/","title":"Install spotpython","text":"<pre><code>pip install spotpython\n</code></pre>"},{"location":"examples/","title":"SPOT Examples","text":"<p>Examples can be found in the Hyperparameter Tuning Cookbook, e.g., Documentation of the Sequential Parameter Optimization.</p>"},{"location":"hyperparameter-tuning-cookbook/","title":"Hyperparameter Tuning Cookbook","text":"<p>The following is a cookbook of hyperparameter tuning recipes. It is not meant to be exhaustive, but instead act as a place to capture a number of the common patterns used in hyperparameter tuning.</p> <p>Hyperparameter Tuning Cookbook</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>spotdesirability<ul> <li>data_utils</li> <li>functions<ul> <li>rsm</li> </ul> </li> <li>plot<ul> <li>ccd</li> </ul> </li> <li>utils<ul> <li>desirability</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/spotdesirability/data_utils/","title":"data_utils","text":""},{"location":"reference/spotdesirability/data_utils/#spotdesirability.data_utils.get_data_folder_path","title":"<code>get_data_folder_path()</code>","text":"<p>Returns the absolute path to the data folder located in the package.</p> Source code in <code>spotdesirability/data_utils.py</code> <pre><code>def get_data_folder_path():\n    \"\"\"Returns the absolute path to the data folder located in the package.\"\"\"\n    # Assume the 'data' directory is within the same package directory\n    current_file_path = os.path.abspath(__file__)\n    package_dir = os.path.dirname(current_file_path)\n    data_folder_path = os.path.join(package_dir, \"data\")\n    return data_folder_path\n</code></pre>"},{"location":"reference/spotdesirability/functions/rsm/","title":"rsm","text":""},{"location":"reference/spotdesirability/functions/rsm/#spotdesirability.functions.rsm.activity_pred","title":"<code>activity_pred(x)</code>","text":"<p>Predicts the thermal activity based on the input vector x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or numpy array</code> <p>A vector of three input values [x1, x2, x3].</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The predicted thermal activity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.functions.rsm import activity_pred\n&gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n&gt;&gt;&gt; activity = activity_pred(x)\n&gt;&gt;&gt; print(activity)\n</code></pre> Source code in <code>spotdesirability/functions/rsm.py</code> <pre><code>def activity_pred(x) -&gt; float:\n    \"\"\"\n    Predicts the thermal activity based on the input vector x.\n\n    Args:\n        x (list or numpy array): A vector of three input values [x1, x2, x3].\n\n    Returns:\n        float: The predicted thermal activity.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.functions.rsm import activity_pred\n        &gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n        &gt;&gt;&gt; activity = activity_pred(x)\n        &gt;&gt;&gt; print(activity)\n    \"\"\"\n    # check if x is a list or numpy array\n    if isinstance(x, list):\n        x = np.array(x)\n    elif not isinstance(x, np.ndarray):\n        raise ValueError(\"Input x must be a list or numpy array.\")\n    # check if x has the correct shape\n    if x.shape != (3,):\n        raise ValueError(\"Input x must be a 3-element vector.\")\n    # Calculate the predicted thermal activity\n    return 59.85 + 3.583 * x[0] + 0.2546 * x[1] + 2.2298 * x[2] + 0.83479 * x[0] ** 2 + 0.07484 * x[1] ** 2 + 0.05716 * x[2] ** 2 - 0.3875 * x[0] * x[1] - 0.375 * x[0] * x[2] + 0.3125 * x[1] * x[2]\n</code></pre>"},{"location":"reference/spotdesirability/functions/rsm/#spotdesirability.functions.rsm.conversion_pred","title":"<code>conversion_pred(x)</code>","text":"<p>Predicts the percent conversion based on the input vector x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or numpy array</code> <p>A vector of three input values [x1, x2, x3].</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The predicted percent conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.functions.rsm import conversion_pred\n&gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n&gt;&gt;&gt; conversion = conversion_pred(x)\n&gt;&gt;&gt; print(conversion)\n</code></pre> Source code in <code>spotdesirability/functions/rsm.py</code> <pre><code>def conversion_pred(x) -&gt; float:\n    \"\"\"\n    Predicts the percent conversion based on the input vector x.\n\n    Args:\n        x (list or numpy array): A vector of three input values [x1, x2, x3].\n\n    Returns:\n        float: The predicted percent conversion.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.functions.rsm import conversion_pred\n        &gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n        &gt;&gt;&gt; conversion = conversion_pred(x)\n        &gt;&gt;&gt; print(conversion)\n    \"\"\"\n    # check if x is a list or numpy array\n    if isinstance(x, list):\n        x = np.array(x)\n    elif not isinstance(x, np.ndarray):\n        raise ValueError(\"Input x must be a list or numpy array.\")\n    # check if x has the correct shape\n    if x.shape != (3,):\n        raise ValueError(\"Input x must be a 3-element vector.\")\n    return 81.09 + 1.0284 * x[0] + 4.043 * x[1] + 6.2037 * x[2] - 1.8366 * x[0] ** 2 + 2.9382 * x[1] ** 2 - 5.1915 * x[2] ** 2 + 2.2150 * x[0] * x[1] + 11.375 * x[0] * x[2] - 3.875 * x[1] * x[2]\n</code></pre>"},{"location":"reference/spotdesirability/functions/rsm/#spotdesirability.functions.rsm.rsm_opt","title":"<code>rsm_opt(x, d_object, prediction_funcs, space='square', alpha=1.682)</code>","text":"<p>Optimization function to calculate desirability. Optimizers minimize, so we return negative desirability.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or ndarray</code> <p>Input parameters (e.g., time, temperature, catalyst).</p> required <code>d_object</code> <code>DOverall</code> <p>Overall desirability object.</p> required <code>prediction_funcs</code> <code>list of callables</code> <p>List of prediction functions to calculate outcomes.</p> required <code>space</code> <code>str</code> <p>Design space (\u201csquare\u201d or \u201ccircular\u201d).</p> <code>'square'</code> <code>alpha</code> <code>float</code> <p>Axial distance for the design space. Default is 1.682 for a rotatable CCD.</p> <code>1.682</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Negative desirability.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>space</code> is not \u201csquare\u201d or \u201ccircular\u201d.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, rsm_opt, DTarget, conversion_pred, activity_pred\n&gt;&gt;&gt; d_object = DOverall(DTarget(0, 0.5, 1), DTarget(0, 0.5, 1))\n&gt;&gt;&gt; prediction_funcs = [conversion_pred, activity_pred]\n&gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n&gt;&gt;&gt; desirability = rsm_opt(x, d_object, prediction_funcs)\n&gt;&gt;&gt; print(desirability)\n-0.5\n</code></pre> Source code in <code>spotdesirability/functions/rsm.py</code> <pre><code>def rsm_opt(x, d_object, prediction_funcs, space=\"square\", alpha=1.682) -&gt; float:\n    \"\"\"\n    Optimization function to calculate desirability.\n    Optimizers minimize, so we return negative desirability.\n\n    Args:\n        x (list or np.ndarray):\n            Input parameters (e.g., time, temperature, catalyst).\n        d_object (DOverall):\n            Overall desirability object.\n        prediction_funcs (list of callables):\n            List of prediction functions to calculate outcomes.\n        space (str):\n            Design space (\"square\" or \"circular\").\n        alpha (float):\n            Axial distance for the design space. Default is 1.682 for a rotatable CCD.\n\n    Returns:\n        float: Negative desirability.\n\n    Raises:\n        ValueError: If `space` is not \"square\" or \"circular\".\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, rsm_opt, DTarget, conversion_pred, activity_pred\n        &gt;&gt;&gt; d_object = DOverall(DTarget(0, 0.5, 1), DTarget(0, 0.5, 1))\n        &gt;&gt;&gt; prediction_funcs = [conversion_pred, activity_pred]\n        &gt;&gt;&gt; x = [1.0, 2.0, 3.0]\n        &gt;&gt;&gt; desirability = rsm_opt(x, d_object, prediction_funcs)\n        &gt;&gt;&gt; print(desirability)\n        -0.5\n    \"\"\"\n    # Apply space constraints first. We use 1.682 = (2^3)^(1/4), see Mont01 a, p.457, as the limit for both circular and square spaces.\n    if space == \"circular\":\n        if np.sqrt(np.sum(np.array(x) ** 2)) &gt; alpha:\n            return 0.0\n    elif space == \"square\":\n        if np.any(np.abs(np.array(x)) &gt; alpha):\n            return 0.0\n    else:\n        raise ValueError(\"space must be 'square' or 'circular'\")\n\n    # Calculate predictions for all provided functions\n    predictions = [func(x) for func in prediction_funcs]\n\n    # Predict desirability using the overall desirability object\n    desirability = d_object.predict(np.array([predictions]))\n\n    # Return negative desirability\n    return -desirability\n</code></pre>"},{"location":"reference/spotdesirability/plot/ccd/","title":"ccd","text":""},{"location":"reference/spotdesirability/plot/ccd/#spotdesirability.plot.ccd.plotCCD","title":"<code>plotCCD(elev=20, azim=30, figsize=(10, 8), filename=None, title='Central Composite Design (CCD) for k=3')</code>","text":"<p>Plots a Central Composite Design (CCD) for k=3 with customizable viewpoint.</p> <p>Parameters:</p> Name Type Description Default <code>elev</code> <code>int</code> <p>Elevation angle in the z-plane for the 3D plot.</p> <code>20</code> <code>azim</code> <code>int</code> <p>Azimuthal angle in the x,y-plane for the 3D plot.</p> <code>30</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure (width, height) in inches. Defaults to (10, 8).</p> <code>(10, 8)</code> <code>filename</code> <code>str</code> <p>The name of the file to save the plot. If None, the plot will be shown instead. Supported formats: \u2018pdf\u2019, \u2018png\u2019.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the plot. Defaults to \u201cCentral Composite Design (CCD) for k=3\u201d.</p> <code>'Central Composite Design (CCD) for k=3'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>spotdesirability/plot/ccd.py</code> <pre><code>def plotCCD(elev=20, azim=30, figsize=(10, 8), filename=None, title=\"Central Composite Design (CCD) for k=3\") -&gt; None:\n    \"\"\"\n    Plots a Central Composite Design (CCD) for k=3 with customizable viewpoint.\n\n    Args:\n        elev (int):\n            Elevation angle in the z-plane for the 3D plot.\n        azim (int):\n            Azimuthal angle in the x,y-plane for the 3D plot.\n        figsize (tuple):\n            Size of the figure (width, height) in inches. Defaults to (10, 8).\n        filename (str, optional):\n            The name of the file to save the plot. If None, the plot will be shown instead. Supported formats: 'pdf', 'png'.\n        title (str):\n            Title of the plot. Defaults to \"Central Composite Design (CCD) for k=3\".\n\n    Returns:\n        None\n    \"\"\"\n    # Define the number of factors (k) and axial distance (alpha)\n    k = 3\n    alpha = np.sqrt(k)  # Rotatable CCD\n\n    # Generate factorial points (2^k design)\n    factorial_points = np.array([[x1, x2, x3] for x1 in [-1, 1] for x2 in [-1, 1] for x3 in [-1, 1]])\n\n    # Generate axial (star) points\n    axial_points = []\n    for i in range(k):\n        point_positive = [0] * k\n        point_negative = [0] * k\n        point_positive[i] = alpha\n        point_negative[i] = -alpha\n        axial_points.append(point_positive)\n        axial_points.append(point_negative)\n    axial_points = np.array(axial_points)\n\n    # Center point\n    center_point = np.array([[0, 0, 0]])\n\n    # Plot the CCD\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n    # Plot factorial points\n    ax.scatter(factorial_points[:, 0], factorial_points[:, 1], factorial_points[:, 2], c=\"blue\", label=\"Factorial Points (2^k)\", s=50)\n\n    # Plot axial points\n    ax.scatter(axial_points[:, 0], axial_points[:, 1], axial_points[:, 2], c=\"red\", label=\"Axial Points (\u00b1\u03b1)\", s=50)\n\n    # Plot center point\n    ax.scatter(center_point[:, 0], center_point[:, 1], center_point[:, 2], c=\"green\", label=\"Center Point\", s=100)\n\n    # Connect edges of the cube (factorial points)\n    for i in range(len(factorial_points)):\n        for j in range(i + 1, len(factorial_points)):\n            # Check if points differ by only one coordinate\n            if np.sum(np.abs(factorial_points[i] - factorial_points[j])) == 2:\n                ax.plot(\n                    [factorial_points[i, 0], factorial_points[j, 0]], [factorial_points[i, 1], factorial_points[j, 1]], [factorial_points[i, 2], factorial_points[j, 2]], color=\"black\", linewidth=0.5\n                )\n\n    # Add axes through the origin\n    ax.plot([-alpha, alpha], [0, 0], [0, 0], color=\"gray\", linestyle=\"--\", label=\"X1 Axis\")\n    ax.plot([0, 0], [-alpha, alpha], [0, 0], color=\"gray\", linestyle=\"--\", label=\"X2 Axis\")\n    ax.plot([0, 0], [0, 0], [-alpha, alpha], color=\"gray\", linestyle=\"--\", label=\"X3 Axis\")\n\n    # Set plot labels\n    ax.set_xlabel(\"X1\")\n    ax.set_ylabel(\"X2\")\n    ax.set_zlabel(\"X3\")\n    if title is not None:\n        ax.set_title(title)\n\n    # Set the viewpoint\n    ax.view_init(elev=elev, azim=azim)\n\n    # Add legend outside the plot\n    ax.legend(bbox_to_anchor=(1.05, 1), loc=\"upper left\", borderaxespad=0)\n\n    save_or_show_plot(plt, filename)\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/","title":"desirability","text":""},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DArb","title":"<code>DArb</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements an arbitrary desirability function.</p> <p>This class allows users to define a custom desirability function by specifying input values (<code>x</code>) and their corresponding desirability values (<code>d</code>).</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>The input values for the desirability function.</p> <code>d</code> <code>ndarray</code> <p>The desirability values corresponding to the input values.</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given input data.</p> <code>plot</code> <p>Plots the desirability function.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Define input and desirability values\n&gt;&gt;&gt; x = [-5, 0, 5, 10]\n&gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n# Create a DArb object\n&gt;&gt;&gt; darb = DArb(x, d)\n# Predict desirability for a range of inputs\n&gt;&gt;&gt; inputs = np.array([-10, -5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = darb.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.  0.  0.5 1.  0.2 0.2]\n# Plot the desirability function\n&gt;&gt;&gt; darb.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DArb(DesirabilityBase):\n    \"\"\"\n    Implements an arbitrary desirability function.\n\n    This class allows users to define a custom desirability function by specifying\n    input values (`x`) and their corresponding desirability values (`d`).\n\n    Attributes:\n        x (numpy.ndarray): The input values for the desirability function.\n        d (numpy.ndarray): The desirability values corresponding to the input values.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given input data.\n\n        plot(add=False, non_inform=True, **kwargs):\n            Plots the desirability function.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Define input and desirability values\n        &gt;&gt;&gt; x = [-5, 0, 5, 10]\n        &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n        # Create a DArb object\n        &gt;&gt;&gt; darb = DArb(x, d)\n        # Predict desirability for a range of inputs\n        &gt;&gt;&gt; inputs = np.array([-10, -5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = darb.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.  0.  0.5 1.  0.2 0.2]\n        # Plot the desirability function\n        &gt;&gt;&gt; darb.plot()\n    \"\"\"\n\n    def __init__(self, x, d, tol=None, missing=None):\n        \"\"\"\n        Initializes the DArb object.\n\n        Args:\n            x (list or numpy.ndarray): The input values for the desirability function.\n            d (list or numpy.ndarray): The desirability values corresponding to the input values.\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If any desirability value is not in the range [0, 1].\n            ValueError: If `x` and `d` do not have the same length.\n            ValueError: If `x` or `d` has fewer than two values.\n        \"\"\"\n        super().__init__()\n        if any(d &gt; 1) or any(d &lt; 0):\n            raise ValueError(\"The desirability values must be 0 &lt;= d &lt;= 1.\")\n        if len(x) != len(d):\n            raise ValueError(\"x and d must have the same length.\")\n        if len(x) &lt; 2 or len(d) &lt; 2:\n            raise ValueError(\"x and d must have at least two values.\")\n\n        self.x = np.array(x)\n        self.d = np.array(d)\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self):\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            float: The mean desirability value over the range `[min(x), max(x)]`.\n        \"\"\"\n        test_seq = np.linspace(min(self.x), max(self.x), 100)\n        return np.mean(self.predict(test_seq))\n\n    def predict(self, newdata=None, missing=None):\n        \"\"\"\n        Predicts the desirability values for the given input data.\n\n        Args:\n            newdata (array-like, optional): The input data for which to compute desirability values.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            (numpy.ndarray): The desirability values for the input data.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n            &gt;&gt;&gt; import numpy as np\n            # Define input and desirability values\n            &gt;&gt;&gt; x = [-5, 0, 5, 10]\n            &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n            &gt;&gt;&gt; darb = DArb(x, d)\n            &gt;&gt;&gt; inputs = np.array([-10, -5, 0, 5, 10, 15])\n            &gt;&gt;&gt; desirability = darb.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [0.  0.  0.5 1.  0.2 0.2]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        out[newdata &lt; min(self.x)] = self.d[0]\n        out[newdata &gt; max(self.x)] = self.d[-1]\n\n        in_between = (newdata &gt;= min(self.x)) &amp; (newdata &lt;= max(self.x))\n        if np.any(in_between):\n            out[in_between] = np.interp(newdata[in_between], self.x, self.d)\n\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n\n    def plot(self, add: bool = False, non_inform: bool = True, xlabel: str = \"Input\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Plots the desirability function.\n\n        Args:\n            add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n            non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n            **kwargs: Additional keyword arguments for the plot.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n            &gt;&gt;&gt; x = [-5, 0, 5, 10]\n            &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n            &gt;&gt;&gt; darb = DArb(x, d)\n            &gt;&gt;&gt; darb.plot()\n        \"\"\"\n        x_range = self.extend_range(self.x)\n        if not add:\n            plt.plot([], [])  # Create an empty plot\n            plt.xlim(x_range)\n            plt.ylim(0, 1)\n            plt.xlabel(xlabel)\n            plt.ylabel(ylabel)\n        input_values = np.linspace(x_range[0], x_range[1], 100)\n        output_values = self.predict(input_values)\n        plt.plot(input_values, output_values, **kwargs)\n        if non_inform:\n            plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n        plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DArb.__init__","title":"<code>__init__(x, d, tol=None, missing=None)</code>","text":"<p>Initializes the DArb object.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or ndarray</code> <p>The input values for the desirability function.</p> required <code>d</code> <code>list or ndarray</code> <p>The desirability values corresponding to the input values.</p> required <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any desirability value is not in the range [0, 1].</p> <code>ValueError</code> <p>If <code>x</code> and <code>d</code> do not have the same length.</p> <code>ValueError</code> <p>If <code>x</code> or <code>d</code> has fewer than two values.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, x, d, tol=None, missing=None):\n    \"\"\"\n    Initializes the DArb object.\n\n    Args:\n        x (list or numpy.ndarray): The input values for the desirability function.\n        d (list or numpy.ndarray): The desirability values corresponding to the input values.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If any desirability value is not in the range [0, 1].\n        ValueError: If `x` and `d` do not have the same length.\n        ValueError: If `x` or `d` has fewer than two values.\n    \"\"\"\n    super().__init__()\n    if any(d &gt; 1) or any(d &lt; 0):\n        raise ValueError(\"The desirability values must be 0 &lt;= d &lt;= 1.\")\n    if len(x) != len(d):\n        raise ValueError(\"x and d must have the same length.\")\n    if len(x) &lt; 2 or len(d) &lt; 2:\n        raise ValueError(\"x and d must have at least two values.\")\n\n    self.x = np.array(x)\n    self.d = np.array(d)\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DArb.plot","title":"<code>plot(add=False, non_inform=True, xlabel='Input', ylabel='Desirability', **kwargs)</code>","text":"<p>Plots the desirability function.</p> <p>Parameters:</p> Name Type Description Default <code>add</code> <code>bool</code> <p>Whether to add the plot to an existing figure. Defaults to False.</p> <code>False</code> <code>non_inform</code> <code>bool</code> <p>Whether to display the non-informative value as a dashed line. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n&gt;&gt;&gt; x = [-5, 0, 5, 10]\n&gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n&gt;&gt;&gt; darb = DArb(x, d)\n&gt;&gt;&gt; darb.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def plot(self, add: bool = False, non_inform: bool = True, xlabel: str = \"Input\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Plots the desirability function.\n\n    Args:\n        add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n        non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n        **kwargs: Additional keyword arguments for the plot.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n        &gt;&gt;&gt; x = [-5, 0, 5, 10]\n        &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n        &gt;&gt;&gt; darb = DArb(x, d)\n        &gt;&gt;&gt; darb.plot()\n    \"\"\"\n    x_range = self.extend_range(self.x)\n    if not add:\n        plt.plot([], [])  # Create an empty plot\n        plt.xlim(x_range)\n        plt.ylim(0, 1)\n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n    input_values = np.linspace(x_range[0], x_range[1], 100)\n    output_values = self.predict(input_values)\n    plt.plot(input_values, output_values, **kwargs)\n    if non_inform:\n        plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n    plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DArb.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>array - like</code> <p>The input data for which to compute desirability values. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The desirability values for the input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n&gt;&gt;&gt; import numpy as np\n# Define input and desirability values\n&gt;&gt;&gt; x = [-5, 0, 5, 10]\n&gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n&gt;&gt;&gt; darb = DArb(x, d)\n&gt;&gt;&gt; inputs = np.array([-10, -5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = darb.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.  0.  0.5 1.  0.2 0.2]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None):\n    \"\"\"\n    Predicts the desirability values for the given input data.\n\n    Args:\n        newdata (array-like, optional): The input data for which to compute desirability values.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        (numpy.ndarray): The desirability values for the input data.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n        &gt;&gt;&gt; import numpy as np\n        # Define input and desirability values\n        &gt;&gt;&gt; x = [-5, 0, 5, 10]\n        &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n        &gt;&gt;&gt; darb = DArb(x, d)\n        &gt;&gt;&gt; inputs = np.array([-10, -5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = darb.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.  0.  0.5 1.  0.2 0.2]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    out[newdata &lt; min(self.x)] = self.d[0]\n    out[newdata &gt; max(self.x)] = self.d[-1]\n\n    in_between = (newdata &gt;= min(self.x)) &amp; (newdata &lt;= max(self.x))\n    if np.any(in_between):\n        out[in_between] = np.interp(newdata[in_between], self.x, self.d)\n\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DBox","title":"<code>DBox</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements a box-like desirability function.</p> <p>The desirability function assigns a value of 1 for inputs within the range <code>[low, high]</code> and a value of 0 for inputs outside this range.</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given input data.</p> <code>plot</code> <p>Plots the desirability function.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Create a DBox object\n&gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n# Predict desirability for a range of inputs\n&gt;&gt;&gt; inputs = np.array([-3, -1.682, 0, 1.682, 3])\n&gt;&gt;&gt; desirability = dbox.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0. 1. 1. 1. 0.]\n# Plot the desirability function\n&gt;&gt;&gt; dbox.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DBox(DesirabilityBase):\n    \"\"\"\n    Implements a box-like desirability function.\n\n    The desirability function assigns a value of 1 for inputs within the range `[low, high]`\n    and a value of 0 for inputs outside this range.\n\n    Attributes:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given input data.\n\n        plot(add=False, non_inform=True, **kwargs):\n            Plots the desirability function.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Create a DBox object\n        &gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n        # Predict desirability for a range of inputs\n        &gt;&gt;&gt; inputs = np.array([-3, -1.682, 0, 1.682, 3])\n        &gt;&gt;&gt; desirability = dbox.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0. 1. 1. 1. 0.]\n        # Plot the desirability function\n        &gt;&gt;&gt; dbox.plot()\n    \"\"\"\n\n    def __init__(self, low, high, tol=None, missing=None):\n        \"\"\"\n        Initializes the DBox object.\n\n        Args:\n            low (float): The lower threshold for the desirability function.\n            high (float): The upper threshold for the desirability function.\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If `low` is greater than or equal to `high`.\n        \"\"\"\n        super().__init__()\n        if low &gt;= high:\n            raise ValueError(\"The low value must be less than the high value.\")\n\n        self.low = low\n        self.high = high\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self):\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            (float): The mean desirability value over the range `[low, high]`.\n        \"\"\"\n        test_seq = np.linspace(self.low, self.high, 100)\n        return np.mean(self.predict(test_seq))\n\n    def predict(self, newdata=None, missing=None):\n        \"\"\"\n        Predicts the desirability values for the given input data.\n\n        Args:\n            newdata (array-like, optional): The input data for which to compute desirability values.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            (numpy.ndarray): The desirability values for the input data.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n            &gt;&gt;&gt; import numpy as np\n            # Create a DBox object\n            &gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n            &gt;&gt;&gt; inputs = np.array([-3, -1.682, 0, 1.682, 3])\n            &gt;&gt;&gt; desirability = dbox.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [0. 1. 1. 1. 0.]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        out[(newdata &lt; self.low) | (newdata &gt; self.high)] = 0\n        out[(newdata &gt;= self.low) &amp; (newdata &lt;= self.high)] = 1\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n\n    def plot(self, add: bool = False, non_inform: bool = True, xlabel: str = \"Input\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Plots the desirability function.\n\n        Args:\n            add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n            non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n            **kwargs: Additional keyword arguments for the plot.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n            &gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n            &gt;&gt;&gt; dbox.plot()\n        \"\"\"\n        x_range = self.extend_range([self.low, self.high])\n        if not add:\n            plt.plot([], [])  # Create an empty plot\n            plt.xlim(x_range)\n            plt.ylim(0, 1)\n            plt.xlabel(xlabel)\n            plt.ylabel(ylabel)\n        plt.hlines(0, x_range[0], self.low, **kwargs)\n        plt.hlines(0, self.high, x_range[1], **kwargs)\n        plt.vlines(self.low, 0, 1, **kwargs)\n        plt.vlines(self.high, 0, 1, **kwargs)\n        plt.hlines(1, self.low, self.high, **kwargs)\n        if non_inform:\n            plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n        plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DBox.__init__","title":"<code>__init__(low, high, tol=None, missing=None)</code>","text":"<p>Initializes the DBox object.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> required <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> required <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>low</code> is greater than or equal to <code>high</code>.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, low, high, tol=None, missing=None):\n    \"\"\"\n    Initializes the DBox object.\n\n    Args:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If `low` is greater than or equal to `high`.\n    \"\"\"\n    super().__init__()\n    if low &gt;= high:\n        raise ValueError(\"The low value must be less than the high value.\")\n\n    self.low = low\n    self.high = high\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DBox.plot","title":"<code>plot(add=False, non_inform=True, xlabel='Input', ylabel='Desirability', **kwargs)</code>","text":"<p>Plots the desirability function.</p> <p>Parameters:</p> Name Type Description Default <code>add</code> <code>bool</code> <p>Whether to add the plot to an existing figure. Defaults to False.</p> <code>False</code> <code>non_inform</code> <code>bool</code> <p>Whether to display the non-informative value as a dashed line. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n&gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n&gt;&gt;&gt; dbox.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def plot(self, add: bool = False, non_inform: bool = True, xlabel: str = \"Input\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Plots the desirability function.\n\n    Args:\n        add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n        non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n        **kwargs: Additional keyword arguments for the plot.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n        &gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n        &gt;&gt;&gt; dbox.plot()\n    \"\"\"\n    x_range = self.extend_range([self.low, self.high])\n    if not add:\n        plt.plot([], [])  # Create an empty plot\n        plt.xlim(x_range)\n        plt.ylim(0, 1)\n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n    plt.hlines(0, x_range[0], self.low, **kwargs)\n    plt.hlines(0, self.high, x_range[1], **kwargs)\n    plt.vlines(self.low, 0, 1, **kwargs)\n    plt.vlines(self.high, 0, 1, **kwargs)\n    plt.hlines(1, self.low, self.high, **kwargs)\n    if non_inform:\n        plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n    plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DBox.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>array - like</code> <p>The input data for which to compute desirability values. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The desirability values for the input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n&gt;&gt;&gt; import numpy as np\n# Create a DBox object\n&gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n&gt;&gt;&gt; inputs = np.array([-3, -1.682, 0, 1.682, 3])\n&gt;&gt;&gt; desirability = dbox.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0. 1. 1. 1. 0.]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None):\n    \"\"\"\n    Predicts the desirability values for the given input data.\n\n    Args:\n        newdata (array-like, optional): The input data for which to compute desirability values.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        (numpy.ndarray): The desirability values for the input data.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DBox\n        &gt;&gt;&gt; import numpy as np\n        # Create a DBox object\n        &gt;&gt;&gt; dbox = DBox(low=-1.682, high=1.682)\n        &gt;&gt;&gt; inputs = np.array([-3, -1.682, 0, 1.682, 3])\n        &gt;&gt;&gt; desirability = dbox.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0. 1. 1. 1. 0.]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    out[(newdata &lt; self.low) | (newdata &gt; self.high)] = 0\n    out[(newdata &gt;= self.low) &amp; (newdata &lt;= self.high)] = 1\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DCategorical","title":"<code>DCategorical</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements a desirability function for categorical inputs.</p> <p>This class allows users to define desirability values for specific categorical inputs.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>dict</code> <p>A dictionary where keys are category names (strings) and values are desirability scores (floats).</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given categorical input data.</p> <code>plot</code> <p>Plots the desirability function for the categorical inputs.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Define desirability values for categories\n&gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n# Create a DCategorical object\n&gt;&gt;&gt; dcat = DCategorical(values)\n# Predict desirability for a list of categories\n&gt;&gt;&gt; inputs = [\"A\", \"B\", \"C\", \"D\"]\n&gt;&gt;&gt; desirability = dcat.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.1 0.9 0.5 ValueError: Value 'D' not in allowed values: ['A', 'B', 'C']]\n# Plot the desirability function\n&gt;&gt;&gt; dcat.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DCategorical(DesirabilityBase):\n    \"\"\"\n    Implements a desirability function for categorical inputs.\n\n    This class allows users to define desirability values for specific categorical inputs.\n\n    Attributes:\n        values (dict): A dictionary where keys are category names (strings) and values are desirability scores (floats).\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given categorical input data.\n\n        plot(non_inform=True, **kwargs):\n            Plots the desirability function for the categorical inputs.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Define desirability values for categories\n        &gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n        # Create a DCategorical object\n        &gt;&gt;&gt; dcat = DCategorical(values)\n        # Predict desirability for a list of categories\n        &gt;&gt;&gt; inputs = [\"A\", \"B\", \"C\", \"D\"]\n        &gt;&gt;&gt; desirability = dcat.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.1 0.9 0.5 ValueError: Value 'D' not in allowed values: ['A', 'B', 'C']]\n        # Plot the desirability function\n        &gt;&gt;&gt; dcat.plot()\n    \"\"\"\n\n    def __init__(self, values, tol=None, missing=None):\n        \"\"\"\n        Initializes the DCategorical object.\n\n        Args:\n            values (dict): A dictionary where keys are category names (strings) and values are desirability scores (floats).\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If `values` has fewer than two entries.\n            ValueError: If keys in `values` are not strings.\n        \"\"\"\n        super().__init__()\n        if len(values) &lt; 2:\n            raise ValueError(\"'values' should have at least two values.\")\n        if not all(isinstance(k, str) for k in values.keys()):\n            raise ValueError(\"'values' should be a named dictionary.\")\n\n        self.values = values\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self):\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            (float): The mean desirability value across all categories.\n        \"\"\"\n        return np.mean(list(self.values.values()))\n\n    def predict(self, newdata=None, missing=None):\n        \"\"\"\n        Predicts the desirability values for the given categorical input data.\n\n        Args:\n            newdata (list or array-like, optional): A list or array of categorical inputs.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            (numpy.ndarray): The desirability values for the input data.\n\n        Raises:\n            ValueError: If a category in `newdata` is not in the allowed categories.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n            &gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n            &gt;&gt;&gt; dcat = DCategorical(values)\n            &gt;&gt;&gt; inputs = [\"A\", \"B\", \"C\"]\n            &gt;&gt;&gt; desirability = dcat.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [0.1 0.9 0.5]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        for i, val in enumerate(newdata):\n            if val in self.values:\n                out[i] = self.values[val]\n            else:\n                raise ValueError(f\"Value '{val}' not in allowed values: {list(self.values.keys())}\")\n\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n\n    def plot(self, non_inform: bool = True, xlabel: str = \"Category\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Plots the desirability function for the categorical inputs.\n\n        Args:\n            non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n            **kwargs: Additional keyword arguments for the plot.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n            &gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n            &gt;&gt;&gt; dcat = DCategorical(values)\n            &gt;&gt;&gt; dcat.plot()\n        \"\"\"\n        plt.bar(range(len(self.values)), list(self.values.values()), tick_label=list(self.values.keys()), **kwargs)\n        plt.ylabel(\"Desirability\")\n        if non_inform:\n            plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n        plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DCategorical.__init__","title":"<code>__init__(values, tol=None, missing=None)</code>","text":"<p>Initializes the DCategorical object.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict</code> <p>A dictionary where keys are category names (strings) and values are desirability scores (floats).</p> required <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>values</code> has fewer than two entries.</p> <code>ValueError</code> <p>If keys in <code>values</code> are not strings.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, values, tol=None, missing=None):\n    \"\"\"\n    Initializes the DCategorical object.\n\n    Args:\n        values (dict): A dictionary where keys are category names (strings) and values are desirability scores (floats).\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If `values` has fewer than two entries.\n        ValueError: If keys in `values` are not strings.\n    \"\"\"\n    super().__init__()\n    if len(values) &lt; 2:\n        raise ValueError(\"'values' should have at least two values.\")\n    if not all(isinstance(k, str) for k in values.keys()):\n        raise ValueError(\"'values' should be a named dictionary.\")\n\n    self.values = values\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DCategorical.plot","title":"<code>plot(non_inform=True, xlabel='Category', ylabel='Desirability', **kwargs)</code>","text":"<p>Plots the desirability function for the categorical inputs.</p> <p>Parameters:</p> Name Type Description Default <code>non_inform</code> <code>bool</code> <p>Whether to display the non-informative value as a dashed line. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n&gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n&gt;&gt;&gt; dcat = DCategorical(values)\n&gt;&gt;&gt; dcat.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def plot(self, non_inform: bool = True, xlabel: str = \"Category\", ylabel: str = \"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Plots the desirability function for the categorical inputs.\n\n    Args:\n        non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n        **kwargs: Additional keyword arguments for the plot.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n        &gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n        &gt;&gt;&gt; dcat = DCategorical(values)\n        &gt;&gt;&gt; dcat.plot()\n    \"\"\"\n    plt.bar(range(len(self.values)), list(self.values.values()), tick_label=list(self.values.keys()), **kwargs)\n    plt.ylabel(\"Desirability\")\n    if non_inform:\n        plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n    plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DCategorical.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given categorical input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>list or array - like</code> <p>A list or array of categorical inputs. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The desirability values for the input data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a category in <code>newdata</code> is not in the allowed categories.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n&gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n&gt;&gt;&gt; dcat = DCategorical(values)\n&gt;&gt;&gt; inputs = [\"A\", \"B\", \"C\"]\n&gt;&gt;&gt; desirability = dcat.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.1 0.9 0.5]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None):\n    \"\"\"\n    Predicts the desirability values for the given categorical input data.\n\n    Args:\n        newdata (list or array-like, optional): A list or array of categorical inputs.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        (numpy.ndarray): The desirability values for the input data.\n\n    Raises:\n        ValueError: If a category in `newdata` is not in the allowed categories.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DCategorical\n        &gt;&gt;&gt; values = {\"A\": 0.1, \"B\": 0.9, \"C\": 0.5}\n        &gt;&gt;&gt; dcat = DCategorical(values)\n        &gt;&gt;&gt; inputs = [\"A\", \"B\", \"C\"]\n        &gt;&gt;&gt; desirability = dcat.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.1 0.9 0.5]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    for i, val in enumerate(newdata):\n        if val in self.values:\n            out[i] = self.values[val]\n        else:\n            raise ValueError(f\"Value '{val}' not in allowed values: {list(self.values.keys())}\")\n\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMax","title":"<code>DMax</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements a desirability function for maximization.</p> <p>The desirability function assigns a value of 0 for inputs below the <code>low</code> threshold, a value of 1 for inputs above the <code>high</code> threshold, and scales the desirability between 0 and 1 for inputs within the range <code>[low, high]</code> using a specified scale factor.</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> <code>scale</code> <code>float</code> <p>The scaling factor for the desirability function. Must be greater than 0.</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given input data.</p> <code>plot</code> <p>Plots the desirability function.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Create a DMax object\n&gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n# Predict desirability for a range of inputs\n&gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = dmax.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0. 0. 0.5 1. 1.]\n# Plot the desirability function\n&gt;&gt;&gt; dmax.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DMax(DesirabilityBase):\n    \"\"\"\n    Implements a desirability function for maximization.\n\n    The desirability function assigns a value of 0 for inputs below the `low` threshold,\n    a value of 1 for inputs above the `high` threshold, and scales the desirability\n    between 0 and 1 for inputs within the range `[low, high]` using a specified scale factor.\n\n    Attributes:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        scale (float): The scaling factor for the desirability function. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given input data.\n\n        plot(add=False, non_inform=True, **kwargs):\n            Plots the desirability function.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Create a DMax object\n        &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n        # Predict desirability for a range of inputs\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = dmax.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0. 0. 0.5 1. 1.]\n        # Plot the desirability function\n        &gt;&gt;&gt; dmax.plot()\n    \"\"\"\n\n    def __init__(self, low, high, scale=1, tol=None, missing=None):\n        \"\"\"\n        Initializes the DMax object.\n\n        Args:\n            low (float): The lower threshold for the desirability function.\n            high (float): The upper threshold for the desirability function.\n            scale (float): The scaling factor for the desirability function. Must be greater than 0.\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If `low` is greater than or equal to `high`.\n            ValueError: If `scale` is less than or equal to 0.\n        \"\"\"\n        super().__init__()\n        if low &gt;= high:\n            raise ValueError(\"The low value must be less than the high value.\")\n        if scale &lt;= 0:\n            raise ValueError(\"The scale parameter must be greater than zero.\")\n\n        self.low = low\n        self.high = high\n        self.scale = scale\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self) -&gt; float:\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            float: The mean desirability value over the range `[low, high]`.\n        \"\"\"\n        test_seq = np.linspace(self.low, self.high, 100)\n        return np.mean(self.predict(test_seq))\n\n    def predict(self, newdata=None, missing=None) -&gt; np.ndarray:\n        \"\"\"\n        Predicts the desirability values for the given input data.\n\n        Args:\n            newdata (array-like, optional): The input data for which to compute desirability values.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            numpy.ndarray: The desirability values for the input data.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n            &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n            &gt;&gt;&gt; desirability = dmax.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [0. 0. 0.5 1. 1.]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        out[newdata &lt; self.low] = 0\n        out[newdata &gt; self.high] = 1\n        mask = (newdata &lt;= self.high) &amp; (newdata &gt;= self.low)\n        out[mask] = ((newdata[mask] - self.low) / (self.high - self.low)) ** self.scale\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMax.__init__","title":"<code>__init__(low, high, scale=1, tol=None, missing=None)</code>","text":"<p>Initializes the DMax object.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> required <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> required <code>scale</code> <code>float</code> <p>The scaling factor for the desirability function. Must be greater than 0.</p> <code>1</code> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>low</code> is greater than or equal to <code>high</code>.</p> <code>ValueError</code> <p>If <code>scale</code> is less than or equal to 0.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, low, high, scale=1, tol=None, missing=None):\n    \"\"\"\n    Initializes the DMax object.\n\n    Args:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        scale (float): The scaling factor for the desirability function. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If `low` is greater than or equal to `high`.\n        ValueError: If `scale` is less than or equal to 0.\n    \"\"\"\n    super().__init__()\n    if low &gt;= high:\n        raise ValueError(\"The low value must be less than the high value.\")\n    if scale &lt;= 0:\n        raise ValueError(\"The scale parameter must be greater than zero.\")\n\n    self.low = low\n    self.high = high\n    self.scale = scale\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMax.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>array - like</code> <p>The input data for which to compute desirability values. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The desirability values for the input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n&gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = dmax.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0. 0. 0.5 1. 1.]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None) -&gt; np.ndarray:\n    \"\"\"\n    Predicts the desirability values for the given input data.\n\n    Args:\n        newdata (array-like, optional): The input data for which to compute desirability values.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        numpy.ndarray: The desirability values for the input data.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = dmax.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0. 0. 0.5 1. 1.]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    out[newdata &lt; self.low] = 0\n    out[newdata &gt; self.high] = 1\n    mask = (newdata &lt;= self.high) &amp; (newdata &gt;= self.low)\n    out[mask] = ((newdata[mask] - self.low) / (self.high - self.low)) ** self.scale\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMin","title":"<code>DMin</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements a desirability function for minimization.</p> <p>The desirability function assigns a value of 1 for inputs below the <code>low</code> threshold, a value of 0 for inputs above the <code>high</code> threshold, and scales the desirability between 1 and 0 for inputs within the range <code>[low, high]</code> using a specified scale factor.</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> <code>scale</code> <code>float</code> <p>The scaling factor for the desirability function. Must be greater than 0.</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given input data.</p> <code>plot</code> <p>Plots the desirability function.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Create a DMin object\n&gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n# Predict desirability for a range of inputs\n&gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = dmin.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[1. 1. 0.5 0. 0.]\n# Plot the desirability function\n&gt;&gt;&gt; dmin.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DMin(DesirabilityBase):\n    \"\"\"\n    Implements a desirability function for minimization.\n\n    The desirability function assigns a value of 1 for inputs below the `low` threshold,\n    a value of 0 for inputs above the `high` threshold, and scales the desirability\n    between 1 and 0 for inputs within the range `[low, high]` using a specified scale factor.\n\n    Attributes:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        scale (float): The scaling factor for the desirability function. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given input data.\n\n        plot(add=False, non_inform=True, **kwargs):\n            Plots the desirability function.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Create a DMin object\n        &gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n        # Predict desirability for a range of inputs\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = dmin.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [1. 1. 0.5 0. 0.]\n        # Plot the desirability function\n        &gt;&gt;&gt; dmin.plot()\n    \"\"\"\n\n    def __init__(self, low, high, scale=1, tol=None, missing=None):\n        \"\"\"\n        Initializes the DMin object.\n\n        Args:\n            low (float): The lower threshold for the desirability function.\n            high (float): The upper threshold for the desirability function.\n            scale (float): The scaling factor for the desirability function. Must be greater than 0.\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If `low` is greater than or equal to `high`.\n            ValueError: If `scale` is less than or equal to 0.\n        \"\"\"\n        super().__init__()\n        if low &gt;= high:\n            raise ValueError(\"The low value must be less than the high value.\")\n        if scale &lt;= 0:\n            raise ValueError(\"The scale parameter must be greater than zero.\")\n\n        self.low = low\n        self.high = high\n        self.scale = scale\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self):\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            float: The mean desirability value over the range `[low, high]`.\n        \"\"\"\n        test_seq = np.linspace(self.low, self.high, 100)\n        return np.mean(self.predict(test_seq))\n\n    def predict(self, newdata=None, missing=None):\n        \"\"\"\n        Predicts the desirability values for the given input data.\n\n        Args:\n            newdata (array-like, optional): The input data for which to compute desirability values.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            (numpy.ndarray): The desirability values for the input data.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n            &gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n            &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n            &gt;&gt;&gt; desirability = dmin.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [1. 1. 0.5 0. 0.]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        out[newdata &lt; self.low] = 1\n        out[newdata &gt; self.high] = 0\n        mask = (newdata &lt;= self.high) &amp; (newdata &gt;= self.low)\n        out[mask] = ((newdata[mask] - self.high) / (self.low - self.high)) ** self.scale\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMin.__init__","title":"<code>__init__(low, high, scale=1, tol=None, missing=None)</code>","text":"<p>Initializes the DMin object.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> required <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> required <code>scale</code> <code>float</code> <p>The scaling factor for the desirability function. Must be greater than 0.</p> <code>1</code> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>low</code> is greater than or equal to <code>high</code>.</p> <code>ValueError</code> <p>If <code>scale</code> is less than or equal to 0.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, low, high, scale=1, tol=None, missing=None):\n    \"\"\"\n    Initializes the DMin object.\n\n    Args:\n        low (float): The lower threshold for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        scale (float): The scaling factor for the desirability function. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If `low` is greater than or equal to `high`.\n        ValueError: If `scale` is less than or equal to 0.\n    \"\"\"\n    super().__init__()\n    if low &gt;= high:\n        raise ValueError(\"The low value must be less than the high value.\")\n    if scale &lt;= 0:\n        raise ValueError(\"The scale parameter must be greater than zero.\")\n\n    self.low = low\n    self.high = high\n    self.scale = scale\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DMin.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>array - like</code> <p>The input data for which to compute desirability values. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The desirability values for the input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n&gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n&gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n&gt;&gt;&gt; desirability = dmin.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[1. 1. 0.5 0. 0.]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None):\n    \"\"\"\n    Predicts the desirability values for the given input data.\n\n    Args:\n        newdata (array-like, optional): The input data for which to compute desirability values.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        (numpy.ndarray): The desirability values for the input data.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n        &gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 5, 10, 15])\n        &gt;&gt;&gt; desirability = dmin.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [1. 1. 0.5 0. 0.]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    out[newdata &lt; self.low] = 1\n    out[newdata &gt; self.high] = 0\n    mask = (newdata &lt;= self.high) &amp; (newdata &gt;= self.low)\n    out[mask] = ((newdata[mask] - self.high) / (self.low - self.high)) ** self.scale\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DOverall","title":"<code>DOverall</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Combines multiple desirability objects into an overall desirability function.</p> <p>This class computes the overall desirability by combining individual desirability objects using the geometric mean of their desirability scores.</p> <p>Attributes:</p> Name Type Description <code>d_objs</code> <code>list</code> <p>A list of desirability objects (e.g., DMax, DMin, DTarget, etc.).</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the overall desirability based on the individual desirability objects.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, DMax, DMin\n&gt;&gt;&gt; import numpy as np\n# Create individual desirability objects\n&gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n&gt;&gt;&gt; dmin = DMin(low=5, high=15, scale=1)\n# Combine them into an overall desirability object\n&gt;&gt;&gt; doverall = DOverall(dmax, dmin)\n# Predict overall desirability for a set of inputs\n&gt;&gt;&gt; inputs = np.array([[5, 10], [0, 15], [10, 5]])\n&gt;&gt;&gt; overall_desirability = doverall.predict(inputs)\n&gt;&gt;&gt; print(overall_desirability)\n# Predict individual and overall desirabilities\n&gt;&gt;&gt; individual, overall = doverall.predict(inputs, all=True)\n&gt;&gt;&gt; print(\"Individual:\", individual)\n&gt;&gt;&gt; print(\"Overall:\", overall)\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DOverall(DesirabilityBase):\n    \"\"\"\n    Combines multiple desirability objects into an overall desirability function.\n\n    This class computes the overall desirability by combining individual desirability objects\n    using the geometric mean of their desirability scores.\n\n    Attributes:\n        d_objs (list): A list of desirability objects (e.g., DMax, DMin, DTarget, etc.).\n\n    Methods:\n        predict(newdata, all=False):\n            Predicts the overall desirability based on the individual desirability objects.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, DMax, DMin\n        &gt;&gt;&gt; import numpy as np\n        # Create individual desirability objects\n        &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n        &gt;&gt;&gt; dmin = DMin(low=5, high=15, scale=1)\n        # Combine them into an overall desirability object\n        &gt;&gt;&gt; doverall = DOverall(dmax, dmin)\n        # Predict overall desirability for a set of inputs\n        &gt;&gt;&gt; inputs = np.array([[5, 10], [0, 15], [10, 5]])\n        &gt;&gt;&gt; overall_desirability = doverall.predict(inputs)\n        &gt;&gt;&gt; print(overall_desirability)\n        # Predict individual and overall desirabilities\n        &gt;&gt;&gt; individual, overall = doverall.predict(inputs, all=True)\n        &gt;&gt;&gt; print(\"Individual:\", individual)\n        &gt;&gt;&gt; print(\"Overall:\", overall)\n    \"\"\"\n\n    def __init__(self, *d_objs):\n        \"\"\"\n        Initializes the DOverall object.\n\n        Args:\n            *d_objs (obj): Instances of desirability classes (e.g., DMax, DTarget, etc.).\n\n        Raises:\n            ValueError: If any object is not an instance of a valid desirability class.\n        \"\"\"\n        super().__init__()\n        valid_classes = (DMax, DMin, DTarget, DArb, DBox, DCategorical)\n\n        if not all(isinstance(obj, valid_classes) for obj in d_objs):\n            raise ValueError(\"All objects must be instances of valid desirability classes.\")\n\n        self.d_objs = d_objs  # Store the desirability objects\n\n    def predict(self, newdata, all=False):\n        \"\"\"\n        Predicts the overall desirability based on the individual desirability objects.\n\n        Args:\n            newdata (list or numpy.ndarray): A list or array of predicted outcomes, one for each desirability object.\n            all (bool, optional): Whether to return individual desirabilities along with the overall desirability.\n                Defaults to False.\n\n        Returns:\n            (float or tuple):\n                The overall desirability score, or a tuple of individual and overall desirabilities if `all=True`.\n\n        Raises:\n            ValueError: If the number of columns in `newdata` does not match the number of desirability objects.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, DMax, DMin\n            &gt;&gt;&gt; import numpy as np\n            # Create individual desirability objects\n            &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n            &gt;&gt;&gt; dmin = DMin(low=5, high=15, scale=1)\n            &gt;&gt;&gt; doverall = DOverall(dmax, dmin)\n            &gt;&gt;&gt; inputs = np.array([[5, 10], [0, 15], [10, 5]])\n            &gt;&gt;&gt; overall_desirability = doverall.predict(inputs)\n            &gt;&gt;&gt; print(overall_desirability)\n        \"\"\"\n        # Ensure newdata is a NumPy array\n        newdata = np.array(newdata)\n\n        # Validate the shape of newdata\n        if newdata.ndim == 1 and len(newdata) != len(self.d_objs):\n            raise ValueError(\"The number of columns in newdata must match the number of desirability objects.\")\n\n        if newdata.ndim == 1:\n            newdata = newdata.reshape(1, -1)  # Reshape 1D array to 2D array with one row\n\n        if newdata.shape[1] != len(self.d_objs):\n            raise ValueError(\"The number of columns in newdata must match the number of desirability objects.\")\n\n        # Compute individual desirabilities\n        individual_desirabilities = [obj.predict(newdata[:, i]) for i, obj in enumerate(self.d_objs)]\n\n        # Compute the geometric mean of the individual desirabilities\n        overall_desirability = np.prod(individual_desirabilities, axis=0) ** (1 / len(individual_desirabilities))\n\n        if all:\n            return individual_desirabilities, overall_desirability\n        return overall_desirability\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DOverall.__init__","title":"<code>__init__(*d_objs)</code>","text":"<p>Initializes the DOverall object.</p> <p>Parameters:</p> Name Type Description Default <code>*d_objs</code> <code>obj</code> <p>Instances of desirability classes (e.g., DMax, DTarget, etc.).</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any object is not an instance of a valid desirability class.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, *d_objs):\n    \"\"\"\n    Initializes the DOverall object.\n\n    Args:\n        *d_objs (obj): Instances of desirability classes (e.g., DMax, DTarget, etc.).\n\n    Raises:\n        ValueError: If any object is not an instance of a valid desirability class.\n    \"\"\"\n    super().__init__()\n    valid_classes = (DMax, DMin, DTarget, DArb, DBox, DCategorical)\n\n    if not all(isinstance(obj, valid_classes) for obj in d_objs):\n        raise ValueError(\"All objects must be instances of valid desirability classes.\")\n\n    self.d_objs = d_objs  # Store the desirability objects\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DOverall.predict","title":"<code>predict(newdata, all=False)</code>","text":"<p>Predicts the overall desirability based on the individual desirability objects.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>list or ndarray</code> <p>A list or array of predicted outcomes, one for each desirability object.</p> required <code>all</code> <code>bool</code> <p>Whether to return individual desirabilities along with the overall desirability. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float or tuple</code> <p>The overall desirability score, or a tuple of individual and overall desirabilities if <code>all=True</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of columns in <code>newdata</code> does not match the number of desirability objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, DMax, DMin\n&gt;&gt;&gt; import numpy as np\n# Create individual desirability objects\n&gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n&gt;&gt;&gt; dmin = DMin(low=5, high=15, scale=1)\n&gt;&gt;&gt; doverall = DOverall(dmax, dmin)\n&gt;&gt;&gt; inputs = np.array([[5, 10], [0, 15], [10, 5]])\n&gt;&gt;&gt; overall_desirability = doverall.predict(inputs)\n&gt;&gt;&gt; print(overall_desirability)\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata, all=False):\n    \"\"\"\n    Predicts the overall desirability based on the individual desirability objects.\n\n    Args:\n        newdata (list or numpy.ndarray): A list or array of predicted outcomes, one for each desirability object.\n        all (bool, optional): Whether to return individual desirabilities along with the overall desirability.\n            Defaults to False.\n\n    Returns:\n        (float or tuple):\n            The overall desirability score, or a tuple of individual and overall desirabilities if `all=True`.\n\n    Raises:\n        ValueError: If the number of columns in `newdata` does not match the number of desirability objects.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DOverall, DMax, DMin\n        &gt;&gt;&gt; import numpy as np\n        # Create individual desirability objects\n        &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n        &gt;&gt;&gt; dmin = DMin(low=5, high=15, scale=1)\n        &gt;&gt;&gt; doverall = DOverall(dmax, dmin)\n        &gt;&gt;&gt; inputs = np.array([[5, 10], [0, 15], [10, 5]])\n        &gt;&gt;&gt; overall_desirability = doverall.predict(inputs)\n        &gt;&gt;&gt; print(overall_desirability)\n    \"\"\"\n    # Ensure newdata is a NumPy array\n    newdata = np.array(newdata)\n\n    # Validate the shape of newdata\n    if newdata.ndim == 1 and len(newdata) != len(self.d_objs):\n        raise ValueError(\"The number of columns in newdata must match the number of desirability objects.\")\n\n    if newdata.ndim == 1:\n        newdata = newdata.reshape(1, -1)  # Reshape 1D array to 2D array with one row\n\n    if newdata.shape[1] != len(self.d_objs):\n        raise ValueError(\"The number of columns in newdata must match the number of desirability objects.\")\n\n    # Compute individual desirabilities\n    individual_desirabilities = [obj.predict(newdata[:, i]) for i, obj in enumerate(self.d_objs)]\n\n    # Compute the geometric mean of the individual desirabilities\n    overall_desirability = np.prod(individual_desirabilities, axis=0) ** (1 / len(individual_desirabilities))\n\n    if all:\n        return individual_desirabilities, overall_desirability\n    return overall_desirability\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DTarget","title":"<code>DTarget</code>","text":"<p>               Bases: <code>DesirabilityBase</code></p> <p>Implements a desirability function for target optimization.</p> <p>The desirability function assigns a value of 0 for inputs outside the range <code>[low, high]</code>, scales the desirability between 0 and 1 for inputs within <code>[low, target]</code> using <code>low_scale</code>, and scales the desirability between 1 and 0 for inputs within <code>[target, high]</code> using <code>high_scale</code>.</p> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> <code>target</code> <code>float</code> <p>The target value for the desirability function.</p> <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> <code>low_scale</code> <code>float</code> <p>The scaling factor for the desirability function below the target. Must be greater than 0.</p> <code>high_scale</code> <code>float</code> <p>The scaling factor for the desirability function above the target. Must be greater than 0.</p> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predicts the desirability values for the given input data.</p> <code>plot</code> <p>Plots the desirability function.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n# Create a DTarget object\n&gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n# Predict desirability for a range of inputs\n&gt;&gt;&gt; inputs = np.array([-5, 0, 2.5, 5, 7.5, 10, 15])\n&gt;&gt;&gt; desirability = dtarget.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.   0.   0.5  1.   0.5  0.   0.  ]\n# Plot the desirability function\n&gt;&gt;&gt; dtarget.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DTarget(DesirabilityBase):\n    \"\"\"\n    Implements a desirability function for target optimization.\n\n    The desirability function assigns a value of 0 for inputs outside the range `[low, high]`,\n    scales the desirability between 0 and 1 for inputs within `[low, target]` using `low_scale`,\n    and scales the desirability between 1 and 0 for inputs within `[target, high]` using `high_scale`.\n\n    Attributes:\n        low (float): The lower threshold for the desirability function.\n        target (float): The target value for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        low_scale (float): The scaling factor for the desirability function below the target. Must be greater than 0.\n        high_scale (float): The scaling factor for the desirability function above the target. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Methods:\n        predict(newdata=None, missing=None):\n            Predicts the desirability values for the given input data.\n\n        plot(add=False, non_inform=True, **kwargs):\n            Plots the desirability function.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        # Create a DTarget object\n        &gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n        # Predict desirability for a range of inputs\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 2.5, 5, 7.5, 10, 15])\n        &gt;&gt;&gt; desirability = dtarget.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.   0.   0.5  1.   0.5  0.   0.  ]\n        # Plot the desirability function\n        &gt;&gt;&gt; dtarget.plot()\n    \"\"\"\n\n    def __init__(self, low, target, high, low_scale=1, high_scale=1, tol=None, missing=None):\n        \"\"\"\n        Initializes the DTarget object.\n\n        Args:\n            low (float): The lower threshold for the desirability function.\n            target (float): The target value for the desirability function.\n            high (float): The upper threshold for the desirability function.\n            low_scale (float): The scaling factor for the desirability function below the target. Must be greater than 0.\n            high_scale (float): The scaling factor for the desirability function above the target. Must be greater than 0.\n            tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n        Raises:\n            ValueError: If `low` is greater than or equal to `high`.\n            ValueError: If `low` is greater than or equal to `target`.\n            ValueError: If `target` is greater than or equal to `high`.\n            ValueError: If `low_scale` or `high_scale` is less than or equal to 0.\n        \"\"\"\n        super().__init__()\n        if low &gt;= high:\n            raise ValueError(\"The low value must be less than the high value.\")\n        if low &gt;= target:\n            raise ValueError(\"The low value must be less than the target.\")\n        if target &gt;= high:\n            raise ValueError(\"The target value must be less than the high value.\")\n        if low_scale &lt;= 0 or high_scale &lt;= 0:\n            raise ValueError(\"The scale parameters must be greater than zero.\")\n\n        self.low = low\n        self.target = target\n        self.high = high\n        self.low_scale = low_scale\n        self.high_scale = high_scale\n        self.tol = tol\n        self.missing = missing\n        if self.missing is None:\n            self.missing = self._calculate_non_informative_value()\n\n    def _calculate_non_informative_value(self):\n        \"\"\"\n        Calculates a non-informative value for missing inputs.\n\n        Returns:\n            float: The mean desirability value over the range `[low, high]`.\n        \"\"\"\n        test_seq = np.linspace(self.low, self.high, 100)\n        return np.mean(self.predict(test_seq))\n\n    def predict(self, newdata=None, missing=None):\n        \"\"\"\n        Predicts the desirability values for the given input data.\n\n        Args:\n            newdata (array-like, optional): The input data for which to compute desirability values.\n                If None, an empty array is used. Defaults to None.\n            missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n        Returns:\n            (numpy.ndarray): The desirability values for the input data.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n            &gt;&gt;&gt; import numpy as np\n            # Create a DTarget object\n            &gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n            &gt;&gt;&gt; inputs = np.array([-5, 0, 2.5, 5, 7.5, 10, 15])\n            &gt;&gt;&gt; desirability = dtarget.predict(inputs)\n            &gt;&gt;&gt; print(desirability)\n            [0.   0.   0.5  1.   0.5  0.   0.  ]\n        \"\"\"\n        if newdata is None:\n            newdata = np.array([])\n        elif isinstance(newdata, (int, float)):  # Handle single float or int input\n            newdata = np.array([newdata])\n        if missing is None:\n            missing = self.missing\n\n        out = np.full(len(newdata), np.nan)\n        out[(newdata &lt; self.low) | (newdata &gt; self.high)] = 0\n        mask_low = (newdata &lt;= self.target) &amp; (newdata &gt;= self.low)\n        out[mask_low] = ((newdata[mask_low] - self.low) / (self.target - self.low)) ** self.low_scale\n        mask_high = (newdata &lt;= self.high) &amp; (newdata &gt;= self.target)\n        out[mask_high] = ((newdata[mask_high] - self.high) / (self.target - self.high)) ** self.high_scale\n        out[np.isnan(out)] = missing\n        if self.tol is not None:\n            out[out == 0] = self.tol\n        return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DTarget.__init__","title":"<code>__init__(low, target, high, low_scale=1, high_scale=1, tol=None, missing=None)</code>","text":"<p>Initializes the DTarget object.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower threshold for the desirability function.</p> required <code>target</code> <code>float</code> <p>The target value for the desirability function.</p> required <code>high</code> <code>float</code> <p>The upper threshold for the desirability function.</p> required <code>low_scale</code> <code>float</code> <p>The scaling factor for the desirability function below the target. Must be greater than 0.</p> <code>1</code> <code>high_scale</code> <code>float</code> <p>The scaling factor for the desirability function above the target. Must be greater than 0.</p> <code>1</code> <code>tol</code> <code>float</code> <p>A tolerance value to replace desirability values of 0. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to a non-informative value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>low</code> is greater than or equal to <code>high</code>.</p> <code>ValueError</code> <p>If <code>low</code> is greater than or equal to <code>target</code>.</p> <code>ValueError</code> <p>If <code>target</code> is greater than or equal to <code>high</code>.</p> <code>ValueError</code> <p>If <code>low_scale</code> or <code>high_scale</code> is less than or equal to 0.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self, low, target, high, low_scale=1, high_scale=1, tol=None, missing=None):\n    \"\"\"\n    Initializes the DTarget object.\n\n    Args:\n        low (float): The lower threshold for the desirability function.\n        target (float): The target value for the desirability function.\n        high (float): The upper threshold for the desirability function.\n        low_scale (float): The scaling factor for the desirability function below the target. Must be greater than 0.\n        high_scale (float): The scaling factor for the desirability function above the target. Must be greater than 0.\n        tol (float, optional): A tolerance value to replace desirability values of 0. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to a non-informative value.\n\n    Raises:\n        ValueError: If `low` is greater than or equal to `high`.\n        ValueError: If `low` is greater than or equal to `target`.\n        ValueError: If `target` is greater than or equal to `high`.\n        ValueError: If `low_scale` or `high_scale` is less than or equal to 0.\n    \"\"\"\n    super().__init__()\n    if low &gt;= high:\n        raise ValueError(\"The low value must be less than the high value.\")\n    if low &gt;= target:\n        raise ValueError(\"The low value must be less than the target.\")\n    if target &gt;= high:\n        raise ValueError(\"The target value must be less than the high value.\")\n    if low_scale &lt;= 0 or high_scale &lt;= 0:\n        raise ValueError(\"The scale parameters must be greater than zero.\")\n\n    self.low = low\n    self.target = target\n    self.high = high\n    self.low_scale = low_scale\n    self.high_scale = high_scale\n    self.tol = tol\n    self.missing = missing\n    if self.missing is None:\n        self.missing = self._calculate_non_informative_value()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DTarget.predict","title":"<code>predict(newdata=None, missing=None)</code>","text":"<p>Predicts the desirability values for the given input data.</p> <p>Parameters:</p> Name Type Description Default <code>newdata</code> <code>array - like</code> <p>The input data for which to compute desirability values. If None, an empty array is used. Defaults to None.</p> <code>None</code> <code>missing</code> <code>float</code> <p>The value to use for missing inputs. Defaults to the object\u2019s <code>missing</code> attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The desirability values for the input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n&gt;&gt;&gt; import numpy as np\n# Create a DTarget object\n&gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n&gt;&gt;&gt; inputs = np.array([-5, 0, 2.5, 5, 7.5, 10, 15])\n&gt;&gt;&gt; desirability = dtarget.predict(inputs)\n&gt;&gt;&gt; print(desirability)\n[0.   0.   0.5  1.   0.5  0.   0.  ]\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def predict(self, newdata=None, missing=None):\n    \"\"\"\n    Predicts the desirability values for the given input data.\n\n    Args:\n        newdata (array-like, optional): The input data for which to compute desirability values.\n            If None, an empty array is used. Defaults to None.\n        missing (float, optional): The value to use for missing inputs. Defaults to the object's `missing` attribute.\n\n    Returns:\n        (numpy.ndarray): The desirability values for the input data.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n        &gt;&gt;&gt; import numpy as np\n        # Create a DTarget object\n        &gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n        &gt;&gt;&gt; inputs = np.array([-5, 0, 2.5, 5, 7.5, 10, 15])\n        &gt;&gt;&gt; desirability = dtarget.predict(inputs)\n        &gt;&gt;&gt; print(desirability)\n        [0.   0.   0.5  1.   0.5  0.   0.  ]\n    \"\"\"\n    if newdata is None:\n        newdata = np.array([])\n    elif isinstance(newdata, (int, float)):  # Handle single float or int input\n        newdata = np.array([newdata])\n    if missing is None:\n        missing = self.missing\n\n    out = np.full(len(newdata), np.nan)\n    out[(newdata &lt; self.low) | (newdata &gt; self.high)] = 0\n    mask_low = (newdata &lt;= self.target) &amp; (newdata &gt;= self.low)\n    out[mask_low] = ((newdata[mask_low] - self.low) / (self.target - self.low)) ** self.low_scale\n    mask_high = (newdata &lt;= self.high) &amp; (newdata &gt;= self.target)\n    out[mask_high] = ((newdata[mask_high] - self.high) / (self.target - self.high)) ** self.high_scale\n    out[np.isnan(out)] = missing\n    if self.tol is not None:\n        out[out == 0] = self.tol\n    return out\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DesirabilityBase","title":"<code>DesirabilityBase</code>","text":"<p>Base class for all desirability functions.</p> <p>Provides a method to print class attributes and extend the range of values.</p> <p>Methods:</p> Name Description <code>print_class_attributes</code> <p>Prints the attributes of the class object in a generic and recursive manner.</p> <code>extend_range</code> <p>Extends the range of values by a given factor.</p> References <p>Many thanks to Max Kuhn for his implementation of the \u2018desirability\u2019 package in R. This class is based on the \u2018desirability\u2019 package in R, see: https://cran.r-project.org/package=desirability</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>class DesirabilityBase:\n    \"\"\"Base class for all desirability functions.\n\n    Provides a method to print class attributes and extend the range of values.\n\n    Methods:\n        print_class_attributes(indent=0):\n            Prints the attributes of the class object in a generic and recursive manner.\n\n        extend_range(values, factor=0.05):\n            Extends the range of values by a given factor.\n\n    References:\n        Many thanks to Max Kuhn for his implementation of the 'desirability' package in R.\n        This class is based on the 'desirability' package in R, see:\n        https://cran.r-project.org/package=desirability\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the DesirabilityBase object.\"\"\"\n        pass\n\n    def print_class_attributes(self, indent=0):\n        \"\"\"\n        Prints the attributes of the class object in a generic and recursive manner.\n\n        Args:\n            indent (int): The indentation level for nested objects.\n        \"\"\"\n        # Print the class name of the current object\n        print(\"\\n\" + \" \" * indent + f\"Class: {type(self).__name__}\")\n\n        # Get the attributes of the object as a dictionary\n        attributes = vars(self)\n        for attr, value in attributes.items():\n            if isinstance(value, DesirabilityBase):  # Check if the attribute is another desirability object\n                print(\" \" * indent + f\"{attr}:\")\n                value.print_class_attributes(indent=indent + 2)  # Recursive call with increased indentation\n            elif isinstance(value, (list, tuple)) and all(isinstance(v, DesirabilityBase) for v in value):\n                print(\" \" * indent + f\"{attr}: [\")\n                for v in value:\n                    v.print_class_attributes(indent=indent + 2)  # Recursive call for each object in the list/tuple\n                print(\" \" * indent + \"]\")\n            else:\n                print(\" \" * indent + f\"{attr}: {value}\")\n\n    def extend_range(self, values, factor=0.05):\n        \"\"\"Extend the range of values by a given factor.\"\"\"\n        range_span = max(values) - min(values)\n        return [min(values) - factor * range_span, max(values) + factor * range_span]\n\n    def plot(self, add: bool = False, non_inform: bool = True, xlabel=\"Input\", ylabel=\"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"\n        Plots the continuous desirability functions, i.e., `DMax`, `DMin`, and `DTarget`.\n\n        Args:\n            add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n            non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n            **kwargs (Dict[str, Any]): Additional keyword arguments for the plot.\n\n        Examples:\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n            &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n            &gt;&gt;&gt; dmax.plot()\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n            &gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n            &gt;&gt;&gt; dmin.plot()\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n            &gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n            &gt;&gt;&gt; dtarget.plot()\n            &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n            &gt;&gt;&gt; x = [-5, 0, 5, 10]\n            &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n            &gt;&gt;&gt; darb = DArb(x, d)\n            &gt;&gt;&gt; darb.plot()\n        \"\"\"\n        x_range = self.extend_range([self.low, self.high])\n        if not add:\n            plt.plot([], [])  # Create an empty plot\n            plt.xlim(x_range)\n            plt.ylim(0, 1)\n            plt.xlabel(xlabel)\n            plt.ylabel(ylabel)\n        plt.hlines(0, x_range[0], self.low, **kwargs)\n        plt.hlines(1, self.high, x_range[1], **kwargs)\n        input_values = np.linspace(self.low, self.high, 100)\n        output_values = self.predict(input_values)\n        plt.plot(input_values, output_values, **kwargs)\n        if non_inform:\n            plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n        plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DesirabilityBase.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the DesirabilityBase object.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the DesirabilityBase object.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DesirabilityBase.extend_range","title":"<code>extend_range(values, factor=0.05)</code>","text":"<p>Extend the range of values by a given factor.</p> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def extend_range(self, values, factor=0.05):\n    \"\"\"Extend the range of values by a given factor.\"\"\"\n    range_span = max(values) - min(values)\n    return [min(values) - factor * range_span, max(values) + factor * range_span]\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DesirabilityBase.plot","title":"<code>plot(add=False, non_inform=True, xlabel='Input', ylabel='Desirability', **kwargs)</code>","text":"<p>Plots the continuous desirability functions, i.e., <code>DMax</code>, <code>DMin</code>, and <code>DTarget</code>.</p> <p>Parameters:</p> Name Type Description Default <code>add</code> <code>bool</code> <p>Whether to add the plot to an existing figure. Defaults to False.</p> <code>False</code> <code>non_inform</code> <code>bool</code> <p>Whether to display the non-informative value as a dashed line. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n&gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n&gt;&gt;&gt; dmax.plot()\n&gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n&gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n&gt;&gt;&gt; dmin.plot()\n&gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n&gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n&gt;&gt;&gt; dtarget.plot()\n&gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n&gt;&gt;&gt; x = [-5, 0, 5, 10]\n&gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n&gt;&gt;&gt; darb = DArb(x, d)\n&gt;&gt;&gt; darb.plot()\n</code></pre> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def plot(self, add: bool = False, non_inform: bool = True, xlabel=\"Input\", ylabel=\"Desirability\", **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"\n    Plots the continuous desirability functions, i.e., `DMax`, `DMin`, and `DTarget`.\n\n    Args:\n        add (bool, optional): Whether to add the plot to an existing figure. Defaults to False.\n        non_inform (bool, optional): Whether to display the non-informative value as a dashed line. Defaults to True.\n        **kwargs (Dict[str, Any]): Additional keyword arguments for the plot.\n\n    Examples:\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMax\n        &gt;&gt;&gt; dmax = DMax(low=0, high=10, scale=1)\n        &gt;&gt;&gt; dmax.plot()\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DMin\n        &gt;&gt;&gt; dmin = DMin(low=0, high=10, scale=1)\n        &gt;&gt;&gt; dmin.plot()\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DTarget\n        &gt;&gt;&gt; dtarget = DTarget(low=0, target=5, high=10, low_scale=1, high_scale=1)\n        &gt;&gt;&gt; dtarget.plot()\n        &gt;&gt;&gt; from spotdesirability.utils.desirability import DArb\n        &gt;&gt;&gt; x = [-5, 0, 5, 10]\n        &gt;&gt;&gt; d = [0, 0.5, 1, 0.2]\n        &gt;&gt;&gt; darb = DArb(x, d)\n        &gt;&gt;&gt; darb.plot()\n    \"\"\"\n    x_range = self.extend_range([self.low, self.high])\n    if not add:\n        plt.plot([], [])  # Create an empty plot\n        plt.xlim(x_range)\n        plt.ylim(0, 1)\n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n    plt.hlines(0, x_range[0], self.low, **kwargs)\n    plt.hlines(1, self.high, x_range[1], **kwargs)\n    input_values = np.linspace(self.low, self.high, 100)\n    output_values = self.predict(input_values)\n    plt.plot(input_values, output_values, **kwargs)\n    if non_inform:\n        plt.axhline(y=self.missing, linestyle=\"--\", **kwargs)\n    plt.show()\n</code></pre>"},{"location":"reference/spotdesirability/utils/desirability/#spotdesirability.utils.desirability.DesirabilityBase.print_class_attributes","title":"<code>print_class_attributes(indent=0)</code>","text":"<p>Prints the attributes of the class object in a generic and recursive manner.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The indentation level for nested objects.</p> <code>0</code> Source code in <code>spotdesirability/utils/desirability.py</code> <pre><code>def print_class_attributes(self, indent=0):\n    \"\"\"\n    Prints the attributes of the class object in a generic and recursive manner.\n\n    Args:\n        indent (int): The indentation level for nested objects.\n    \"\"\"\n    # Print the class name of the current object\n    print(\"\\n\" + \" \" * indent + f\"Class: {type(self).__name__}\")\n\n    # Get the attributes of the object as a dictionary\n    attributes = vars(self)\n    for attr, value in attributes.items():\n        if isinstance(value, DesirabilityBase):  # Check if the attribute is another desirability object\n            print(\" \" * indent + f\"{attr}:\")\n            value.print_class_attributes(indent=indent + 2)  # Recursive call with increased indentation\n        elif isinstance(value, (list, tuple)) and all(isinstance(v, DesirabilityBase) for v in value):\n            print(\" \" * indent + f\"{attr}: [\")\n            for v in value:\n                v.print_class_attributes(indent=indent + 2)  # Recursive call for each object in the list/tuple\n            print(\" \" * indent + \"]\")\n        else:\n            print(\" \" * indent + f\"{attr}: {value}\")\n</code></pre>"}]}